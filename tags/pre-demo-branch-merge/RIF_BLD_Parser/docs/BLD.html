<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html dir="ltr" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>

	
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
				<meta name="keywords" content="BLD,DTB,FLD,RIF Working Group,SWC,UCR">
		<link rel="shortcut icon" href="http://www.w3.org/favicon.ico">
		<link rel="search" type="application/opensearchdescription+xml" href="http://www.w3.org/2005/rules/wiki/opensearch_desc.php" title="RIF (English)">
<link rel="alternate" type="application/rss+xml" title="RIF RSS Feed" href="http://www.w3.org/2005/rules/wiki/index.php?title=Special:Recentchanges&amp;feed=rss">
<link rel="alternate" type="application/atom+xml" title="RIF Atom Feed" href="http://www.w3.org/2005/rules/wiki/index.php?title=Special:Recentchanges&amp;feed=atom">
		<title>BLD - RIF</title>
		<style type="text/css" media="screen,projection">/*<![CDATA[*/ @import "/2005/rules/wiki/skins/w3cmonobook/main.css?116"; /*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print" href="BLD_files/commonPrint.css">
		<link rel="stylesheet" type="text/css" media="handheld" href="BLD_files/handheld.css">
		<!--[if lt IE 5.5000]><style type="text/css">@import "/2005/rules/wiki/skins/w3cmonobook/IE50Fixes.css?116";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/2005/rules/wiki/skins/w3cmonobook/IE55Fixes.css?116";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/2005/rules/wiki/skins/w3cmonobook/IE60Fixes.css?116";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/2005/rules/wiki/skins/w3cmonobook/IE70Fixes.css?116";</style><![endif]-->
		<!--[if lt IE 7]><script type="text/javascript" src="/2005/rules/wiki/skins/common/IEFixes.js?116"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
		
		<script type="text/javascript">/*<![CDATA[*/
var skin = "w3cmonobook";
var stylepath = "/2005/rules/wiki/skins";
var wgArticlePath = "/2005/rules/wiki/$1";
var wgScriptPath = "/2005/rules/wiki";
var wgScript = "/2005/rules/wiki/index.php";
var wgServer = "http://www.w3.org";
var wgCanonicalNamespace = "";
var wgCanonicalSpecialPageName = false;
var wgNamespaceNumber = 0;
var wgPageName = "BLD";
var wgTitle = "BLD";
var wgAction = "view";
var wgRestrictionEdit = [];
var wgRestrictionMove = [];
var wgArticleId = "22";
var wgIsArticle = true;
var wgUserName = null;
var wgUserGroups = null;
var wgUserLanguage = "en";
var wgContentLanguage = "en";
var wgBreakFrames = false;
var wgCurRevisionId = "10525";
var wgVersion = "1.12.0";
var wgEnableAPI = true;
var wgEnableWriteAPI = false;
/*]]>*/</script>
                
		<script type="text/javascript" src="BLD_files/wikibits.js"><!-- wikibits js --></script>
		<script type="text/javascript" src="BLD_files/index.php"><!-- site js --></script>
		<style type="text/css">/*<![CDATA[*/
@import "/2005/rules/wiki/index.php?title=MediaWiki:Common.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
@import "/2005/rules/wiki/index.php?title=MediaWiki:W3cmonobook.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
@import "/2005/rules/wiki/index.php?title=-&action=raw&gen=css&maxage=18000";
/*]]>*/</style>
		<!-- Head Scripts -->
		<link rel="stylesheet" type="text/css" href="BLD_files/index.css">		<script type="text/javascript" src="BLD_files/ajax.js"></script>
<style type="text/css">
li#pt-openidlogin {
  background: url(http://www.openid.net/login-bg.gif) top left no-repeat;
  padding-left: 20px;
  text-transform: none;
}
</style>	</head><body class="mediawiki ns-0 ltr page-BLD">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
				<h1 class="firstHeading">BLD</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From RIF</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<p><br>           
</p>
<dl><dt>Document title<b>:</b>
</dt><dd><span id="full-title"><span id="short-title">RIF Basic Logic Dialect</span></span>
</dd></dl>
<div id="editors">
<dl><dt> Editors</dt><dd>
</dd><dd> Harold Boley, National Research Council, Canada
</dd><dd> Michael Kifer, State University of New York at Stony Brook, USA
</dd></dl>
</div>
<dl><dt> Abstract
</dt><dd> <div id="abstract"><p>This document, developed by the <a href="http://www.w3.org/2005/rules/wiki/RIF_Working_Group" title="RIF Working Group">Rule Interchange Format (RIF) Working Group</a>,
specifies the Basic Logic Dialect, RIF-BLD, a format that allows logic
rules to be exchanged between rule systems. The RIF-BLD presentation
syntax and semantics are specified both directly and as specializations
of the <i>RIF Framework for Logic Dialects</i>, or RIF-FLD. The XML
serialization syntax of RIF-BLD is specified via a mapping from the
presentation syntax. A normative XML schema is also provided.</p> </div>
</dd><dt> Status of this Document
</dt><dd> @@update This is an automatically generated Mediawiki page, made from some sort of W3C-style spec.
</dd></dl>
<p><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright" class="external text" title="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2009 <a href="http://www.w3.org/" class="external text" title="http://www.w3.org/">W3C</a><sup>®</sup> (<a href="http://www.csail.mit.edu/" class="external text" title="http://www.csail.mit.edu/">MIT</a>, <a href="http://www.ercim.org/" class="external text" title="http://www.ercim.org/">ERCIM</a>, <a href="http://www.keio.ac.jp/" class="external text" title="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer" class="external text" title="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks" class="external text" title="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents" class="external text" title="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
</p><p><br>
</p>
<div id="docbody">
<table id="toc" class="toc" summary="Contents"><tbody><tr><td><div id="toctitle"><h2>Contents</h2> <span class="toctoggle">[<a href="javascript:toggleToc()" class="internal" id="togglelink">hide</a>]</span></div>
<ul>
<li class="toclevel-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1"><a href="#Direct_Specification_of_RIF-BLD_Presentation_Syntax"><span class="tocnumber">2</span> <span class="toctext">Direct Specification of RIF-BLD Presentation Syntax</span></a>
<ul>
<li class="toclevel-2"><a href="#Alphabet_of_RIF-BLD"><span class="tocnumber">2.1</span> <span class="toctext">Alphabet of RIF-BLD</span></a></li>
<li class="toclevel-2"><a href="#Terms"><span class="tocnumber">2.2</span> <span class="toctext">Terms</span></a></li>
<li class="toclevel-2"><a href="#Formulas"><span class="tocnumber">2.3</span> <span class="toctext">Formulas</span></a></li>
<li class="toclevel-2"><a href="#RIF-BLD_Annotations_in_the_Presentation_Syntax"><span class="tocnumber">2.4</span> <span class="toctext">RIF-BLD Annotations in the Presentation Syntax</span></a></li>
<li class="toclevel-2"><a href="#Well-formed_Formulas"><span class="tocnumber">2.5</span> <span class="toctext">Well-formed Formulas</span></a></li>
<li class="toclevel-2"><a href="#EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-BLD_.28Informative.29"><span class="tocnumber">2.6</span> <span class="toctext">EBNF Grammar for the Presentation Syntax of RIF-BLD (Informative)</span></a>
<ul>
<li class="toclevel-3"><a href="#EBNF_for_the_Condition_Language"><span class="tocnumber">2.6.1</span> <span class="toctext">EBNF for the Condition Language</span></a></li>
<li class="toclevel-3"><a href="#EBNF_for_the_Rule_Language"><span class="tocnumber">2.6.2</span> <span class="toctext">EBNF for the Rule Language</span></a></li>
<li class="toclevel-3"><a href="#EBNF_for_Annotations"><span class="tocnumber">2.6.3</span> <span class="toctext">EBNF for Annotations</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Direct_Specification_of_RIF-BLD_Semantics"><span class="tocnumber">3</span> <span class="toctext">Direct Specification of RIF-BLD Semantics</span></a>
<ul>
<li class="toclevel-2"><a href="#Truth_Values"><span class="tocnumber">3.1</span> <span class="toctext">Truth Values</span></a></li>
<li class="toclevel-2"><a href="#Semantic_Structures"><span class="tocnumber">3.2</span> <span class="toctext">Semantic Structures</span></a></li>
<li class="toclevel-2"><a href="#RIF-BLD_Annotations_in_the_Semantics"><span class="tocnumber">3.3</span> <span class="toctext">RIF-BLD Annotations in the Semantics</span></a></li>
<li class="toclevel-2"><a href="#Interpretation_of_Non-document_Formulas"><span class="tocnumber">3.4</span> <span class="toctext">Interpretation of Non-document Formulas</span></a></li>
<li class="toclevel-2"><a href="#Interpretation_of_Documents"><span class="tocnumber">3.5</span> <span class="toctext">Interpretation of Documents</span></a></li>
<li class="toclevel-2"><a href="#Logical_Entailment"><span class="tocnumber">3.6</span> <span class="toctext">Logical Entailment</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#XML_Serialization_Syntax_for_RIF-BLD"><span class="tocnumber">4</span> <span class="toctext">XML Serialization Syntax for RIF-BLD</span></a>
<ul>
<li class="toclevel-2"><a href="#XML_for_the_Condition_Language"><span class="tocnumber">4.1</span> <span class="toctext">XML for the Condition Language</span></a></li>
<li class="toclevel-2"><a href="#XML_for_the_Rule_Language"><span class="tocnumber">4.2</span> <span class="toctext">XML for the Rule Language</span></a></li>
<li class="toclevel-2"><a href="#Mapping_from_the_Presentation_Syntax_to_the_XML_Syntax"><span class="tocnumber">4.3</span> <span class="toctext">Mapping from the Presentation Syntax to the XML Syntax</span></a>
<ul>
<li class="toclevel-3"><a href="#Mapping_of_the_Condition_Language"><span class="tocnumber">4.3.1</span> <span class="toctext">Mapping of the Condition Language</span></a></li>
<li class="toclevel-3"><a href="#Mapping_of_the_Rule_Language"><span class="tocnumber">4.3.2</span> <span class="toctext">Mapping of the Rule Language</span></a></li>
<li class="toclevel-3"><a href="#Mapping_of_Annotations"><span class="tocnumber">4.3.3</span> <span class="toctext">Mapping of Annotations</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Conformance_Clauses"><span class="tocnumber">5</span> <span class="toctext">Conformance Clauses</span></a></li>
<li class="toclevel-1"><a href="#RIF-BLD_as_a_Specialization_of_the_RIF_Framework_for_Logic_Dialects_.5BRIF-FLD.5D"><span class="tocnumber">6</span> <span class="toctext">RIF-BLD as a Specialization of the RIF Framework for Logic Dialects [RIF-FLD]</span></a>
<ul>
<li class="toclevel-2"><a href="#The_Presentation_Syntax_of_RIF-BLD_as_a_Specialization_of_RIF-FLD"><span class="tocnumber">6.1</span> <span class="toctext">The Presentation Syntax of RIF-BLD as a Specialization of RIF-FLD</span></a></li>
<li class="toclevel-2"><a href="#The_Semantics_of_RIF-BLD_as_a_Specialization_of_RIF-FLD"><span class="tocnumber">6.2</span> <span class="toctext">The Semantics of RIF-BLD as a Specialization of RIF-FLD</span></a></li>
<li class="toclevel-2"><a href="#The_XML_Serialization_of_RIF-BLD_as_a_Specialization_of_RIF-FLD"><span class="tocnumber">6.3</span> <span class="toctext">The XML Serialization of RIF-BLD as a Specialization of RIF-FLD</span></a></li>
<li class="toclevel-2"><a href="#RIF-BLD_Conformance_as_a_Specialization_of_RIF-FLD"><span class="tocnumber">6.4</span> <span class="toctext">RIF-BLD Conformance as a Specialization of RIF-FLD</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Acknowledgements"><span class="tocnumber">7</span> <span class="toctext">Acknowledgements</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a>
<ul>
<li class="toclevel-2"><a href="#Normative_References"><span class="tocnumber">8.1</span> <span class="toctext">Normative References</span></a></li>
<li class="toclevel-2"><a href="#Informational_References"><span class="tocnumber">8.2</span> <span class="toctext">Informational References</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_XML_Schema_for_RIF-BLD"><span class="tocnumber">9</span> <span class="toctext">Appendix: XML Schema for RIF-BLD</span></a>
<ul>
<li class="toclevel-2"><a href="#Condition_Language"><span class="tocnumber">9.1</span> <span class="toctext">Condition Language</span></a></li>
<li class="toclevel-2"><a href="#Rule_Language"><span class="tocnumber">9.2</span> <span class="toctext">Rule Language</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_Changes_Since_the_Last_Call_Version_.282008-07-30.29"><span class="tocnumber">10</span> <span class="toctext">Appendix: Changes Since the Last Call Version (2008-07-30)</span></a></li>
</ul>


</td></tr></tbody></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<a name="Overview"></a><h2> <span class="mw-headline">1  Overview </span></h2>
<p><span id="overview" class="anchor"></span> This specification develops <i><b>RIF-BLD</b></i> (the <b>B</b>asic <b>L</b>ogic <b>D</b>ialect of the <b>R</b>ule <b>I</b>nterchange <b>F</b>ormat).
From a theoretical perspective, RIF-BLD corresponds to the language of
definite Horn rules with equality and a standard first-order semantics [<a href="#ref-chang-lee" title="">CL73</a>]. Syntactically, RIF-BLD has a number of extensions to support features such as objects and frames as in F-logic [<a href="#ref-flogic-95" title="">KLW95</a>], internationalized resource identifiers (or IRIs, defined by [<a href="#ref-rfc-3987" title="">RFC-3987</a>]) as identifiers for concepts, and XML Schema datatypes [<a href="#ref-xml-schema2" title="">XML-SCHEMA2</a>]. In addition, RIF RDF and OWL Compatibility [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>]
defines semantics for the integrated RIF-BLD/RDF and RIF-BLD/OWL
languages. These features make RIF-BLD a Web-aware language. However,
it should be kept in mind that RIF is designed to enable
interoperability among rule languages in general, and its uses are not
limited to the Web. </p><p>While rule interchange (and not, e.g., execution) is the
principle design goal for RIF-BLD, the design clearly indicates a
decision to avoid solving the (probably impossible) problem of rule
interchange in general. Instead, the design of RIF reflects the
rationale of identifying specific kinds of rules within existing rule
systems, called <i>RIF dialects</i>, that can be translated into other
rule systems without changing their meaning. RIF-BLD is just the first
in a series of such dialects. In particular, RIF-BLD has the RIF-Core
dialect [<a href="#ref-rif-core" title="">RIF-Core</a>] as a subset. It is <i>not expected</i>
that most rule systems will be able to translate all their rules into
RIF-BLD, rather it is expected that only certain kinds of rules will be
translatable. Since there are many existing rule languages with useful
features that are not supported in RIF-BLD, it is expected that RIF-BLD
translators will not translate rules that use such features. This could
drive the design of "BLD-specific" rule sets in which rules are
specifically written by the implementor to be within the BLD dialect
and thus be portable between many rule system implementations. </p><p>Among its many influences, RIF shares certain characteristics with ISO Common Logic (CL) [<a href="#ref-common-logic" title="">ISO-CL</a>], itself an evolution of KIF [<a href="#ref-kif" title="">KIF</a>] and Conceptual Graphs [<a href="#ref-cg" title="">CG</a>].
Like CL, RIF employs XML as its primary normative syntax, uses IRIs as
identifiers, specifies integrated RIF-BLD/RDF and RIF-BLD/OWL languages
for Semantic Web Compatibility [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>],
and provides a rich set of datatypes and built-ins that are designed to
be well aligned with Web-aware rule system implementations [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. Unlike CL, RIF-BLD was designed to be a <i>simple</i>
dialect with limited expressiveness that lies within the intersection
of first-order and logic-programming systems. This is why RIF-BLD does
not support negation. More generally, RIF-BLD is part of a coherent
array of RIF rule dialects, which encompasses both logic rules --
through the RIF framework for logic dialects [<a href="#ref-rif-fld" title="">RIF-FLD</a>] also including a variety of rule languages based on non-monotonic theories -- and production rules, as defined in [<a href="#ref-rif-prd" title="">RIF-PRD</a>].
CL, on the other hand, is strictly first-order; it does not account for
non-monotonic semantics (e.g. negation as failure, defaults,
priorities, etc.). For rule interchange between CL and RIF dialects, it
is expected that partial RIF-CL mappings will be defined.
</p><p>RIF-BLD also bears some similarity to SPARQL, in particular with respect to RDF Compatibility [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>].
As with the well-known correspondence between a fragment of SQL and
Datalog, SPARQL can be partially mapped to Datalog (and thus to the
RIF-Core subset of RIF-BLD), see [<a href="#ref-sparql-rules" title="">AP07</a>] and [<a href="#ref-sparql-expr" title="">AG08</a>]
for details. A full mapping of SPARQL would need constructs beyond
RIF-BLD, such as non-monotonic negation. Likewise, not all of SPARQL's
FILTER functions are expressible in RIF-DTB built-in predicates. Not
all of RIF-BLD is expressible in SPARQL either, for instance recursive
rules over RDF Data are not expressible as SPARQL CONSTRUCT statements.
</p><p>RIF-BLD is defined in two different ways -- <i>both normative</i>:
</p>
<ul>
  <li>
    As a direct specification, independently of the RIF framework for logic dialects [<a href="#ref-rif-fld" title="">RIF-FLD</a>],
for the benefit of those who desire a direct path to RIF-BLD, e.g., as
prospective implementers, and are not interested in extensibility
issues. This version of the RIF-BLD specification is given first. </li>
  <li>
    As a specialization of the RIF framework for logic dialects [<a href="#ref-rif-fld" title="">RIF-FLD</a>], which is part of the RIF extensibility framework.

    Building on RIF-FLD, this version of the RIF-BLD specification is comparatively short and is presented in Section <a href="#sec-bld-fld-spec" title="">RIF-BLD as a Specialization of the RIF Framework</a>
at the end of this document. This is intended for the reader who is
already familiar with RIF-FLD and does not need to go through the much
longer direct specification of RIF-BLD. This section is also useful for
dialect designers, as it is a concrete example of how a non-trivial RIF
dialect can be derived from the RIF framework for logic dialects. </li>
</ul>
<p>Logic-based RIF dialects that specialize or extend RIF-BLD in accordance with the RIF framework for logic dialects [<a href="#ref-rif-fld" title="">RIF-FLD</a>]
include RIF-Core as a specialization of RIF-BLD. It is expected that
other specifications will develop further logic dialects based on
RIF-BLD such as a RIF-BLD extension capturing uncertainty [<a href="#ref-rif-urd" title="">URD08</a>].
</p><p>As a preview, here is a simple complete RIF-BLD example deriving a ternary relation from its inverse.
</p><p><b>Example 1</b> (An introductory RIF-BLD example).
</p><p>A rule can be written in English to derive the <tt>buy</tt> relationships
(rather than store them) from the <tt>sell</tt> relationships that are
stored as facts (e.g., as exemplified by the English statement below):
</p>
<ul>
  <li>
   <em>
     A buyer buys an item from a seller
     if the seller sells the item to the buyer.
   </em>
  </li>
  <li>
   <em>
     John sells LeRif to Mary.
   </em>
  </li>
</ul>
<p>Intuitively, the fact <i>Mary buys LeRif from John</i> should be logically derivable from the above premises.
Assuming Web IRIs for the predicates <tt>buy</tt> and <tt>sell</tt>, as well as for the individuals
<tt>John</tt>, <tt>Mary</tt>, and <tt>LeRif</tt>, the above English text can be represented in the <a href="#sec-bld-direct-syntax" title="">RIF-BLD Presentation Syntax</a> as follows.
</p>
<pre>Document(
  Prefix(cpt &lt;http://example.com/concepts#&gt;)
  Prefix(ppl &lt;http://example.com/people#&gt;)
  Prefix(bks &lt;http://example.com/books#&gt;)

  Group
  (
    Forall&nbsp;?Buyer&nbsp;?Item&nbsp;?Seller (
        cpt:buy(?Buyer&nbsp;?Item&nbsp;?Seller)&nbsp;:- cpt:sell(?Seller&nbsp;?Item&nbsp;?Buyer)
    )
 
    cpt:sell(ppl:John bks:LeRif ppl:Mary)
  )
)
</pre>
<p><br>
Whenever a RIF-BLD document falls into the Core subset or can be
translated to it, the document should be produced in RIF-Core to allow
its interchange with a maximum number of RIF consumers.
For instance, the Datalog-like RIF document in Example 1 is also a
RIF-Core example.
</p><p>For the interchange of documents containing RIF-BLD rules (and facts), a concrete <a href="#sec-xml-bld" title="">RIF-BLD XML Syntax</a> is given in this specification. To formalize their meaning, a model-theoretic <a href="#sec-bld-direct-semantics" title="">RIF-BLD Semantics</a> is specified.
</p><p><span id="sec-bld-direct-syntax" class="anchor"></span>
</p>
<a name="Direct_Specification_of_RIF-BLD_Presentation_Syntax"></a><h2> <span class="mw-headline">2  Direct Specification of RIF-BLD Presentation Syntax </span></h2>
<p>This section specifies the <i><b>presentation syntax</b></i> of RIF-BLD directly, without relying on [<a href="#ref-rif-fld" title="">RIF-FLD</a>]. In the first five (normative) subsections, the presentation syntax is
defined using "mathematical English," a special form of English for communicating mathematical definitions, examples, etc.
In the non-normative subsection <a href="#sec-concrete-syntax" title="">EBNF Grammar for the Presentation Syntax of RIF-BLD</a>,
a grammar for a superset of the presentation syntax is given using
Extended Backus–Naur Form (EBNF).
Neither the mathematical English nor the EBNF is intended to be a
concrete syntax for RIF-BLD. The mathematical English deliberately
leaves out details such as the delimiters of the various syntactic
components, escape symbols, parenthesizing, precedence of operators,
and the like. The EBNF does not specify context-sensitive syntactic
constraints.
Since RIF is an interchange format, it uses <i><b>XML as the only concrete syntax</b></i>,
which will be defined in <a href="#sec-xml-bld" title="">XML Serialization Syntax for RIF-BLD</a>. Hence <a href="#sec-conformance" title="">RIF-BLD conformance</a> is described in terms of <a href="#def-conformance" title="">semantics-preserving transformations</a>.
</p><p>Note to the reader: this section depends on Section <a href="http://www.w3.org/2005/rules/wiki/DTB#sec-constants" title="DTB">Constants, Symbol Spaces, and Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p><p><br>
<span id="sec-alphabet" class="anchor"></span> 
</p>
<a name="Alphabet_of_RIF-BLD"></a><h4> <span class="mw-headline">2.1  Alphabet of RIF-BLD </span></h4>
<p><span id="def-bld-alphabet" class="anchor"></span> 
<b>Definition (Alphabet)</b>.
The <i><b>alphabet</b></i> of the presentation language of RIF-BLD consists of 
</p>
<ul><li> a countably infinite set of <i><b>constant symbols</b></i> <tt>Const</tt>
</li><li> a countably infinite set of <i><b>variable symbols</b></i> <tt>Var</tt> (disjoint from <tt>Const</tt>)
</li><li> a countably infinite set of argument names, <tt>ArgNames</tt> (disjoint from <tt>Const</tt> and <tt>Var</tt>)
</li><li> connective symbols <tt>And</tt>, <tt>Or</tt>, and <tt>:-</tt>
</li><li> quantifiers <tt>Exists</tt> and <tt>Forall</tt>
</li><li> the symbols <tt>=</tt>, <tt>#</tt>, <tt>##</tt>, <tt>-&gt;</tt>, <tt>External</tt>, <tt>Import</tt>, <tt>Prefix</tt>, and <tt>Base</tt> 
</li><li> the symbols <tt>Group</tt> and <tt>Document</tt>
</li><li> the symbols for representing lists: <tt>List</tt> and <tt>OpenList</tt>.  
</li><li> the auxiliary symbols <tt>(</tt>, <tt>)</tt>, <tt>[</tt>, <tt>]</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, and <tt>^^</tt>
</li></ul>
<p>The set of connective symbols, quantifiers, <tt>=</tt>, etc., is disjoint from <tt>Const</tt> and <tt>Var</tt>. The argument names in <tt>ArgNames</tt> are written as Unicode strings that must not start with a question mark, "<tt>?</tt>". Variables are written as Unicode strings preceded with the symbol "<tt>?</tt>". 
</p><p>Constants are written as <tt>"literal"^^symspace</tt>, where <tt>literal</tt> is a sequence of Unicode characters and
<tt>symspace</tt> is an identifier for a symbol space. Symbol spaces are defined in Section <a href="http://www.w3.org/2005/rules/wiki/DTB#sec-constants" title="DTB">Constants, Symbol Spaces, and Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p><p>The symbols <tt>=</tt>, <tt>#</tt>, and <tt>##</tt> are used in formulas that define equality, class membership, and subclass relationships. The symbol <tt>-&gt;</tt> is used in terms that have named arguments and in frame formulas. The symbol <tt>External</tt> indicates that an atomic formula or a function term is defined externally (e.g., a built-in)  and the symbols <tt>Prefix</tt> and <tt>Base</tt> enable compact representations of IRIs [<a href="#ref-rfc-3987" title="">RFC-3987</a>].
</p><p>The symbol <tt>Document</tt> is used to specify RIF-BLD documents, the symbol <tt>Import</tt> is an import directive, and the symbol <tt>Group</tt> is used to organize RIF-BLD formulas into collections. &nbsp;&nbsp;☐
</p><p>The language of RIF-BLD is the set of formulas constructed using the above alphabet according to the rules given below. 
</p><p><br>
<span id="sec-terms" class="anchor"></span>
</p>
<a name="Terms"></a><h4> <span class="mw-headline">2.2  Terms </span></h4>
<p>RIF-BLD defines several kinds of terms: <i>constants</i> and <i>variables</i>,
<i>positional</i> terms, terms with <i>named arguments</i>, plus <i>equality</i>,
<i>membership</i>, <i>subclass</i>, <i>frame</i>, and <i>external</i> terms. The word "<i>term</i>" will be used to refer to any of these constructs.
</p><p>To simplify the next definition, we will use the phrase <i>base term</i> to refer to simple, positional, or named-argument terms, or to terms of the form <tt>External(t)</tt>, where <tt>t</tt> is a positional or a named-argument term.
</p><p><span id="def-bld-term" class="anchor"></span> 
<b>Definition (Term)</b>.
</p>
<ol>
  <li><i>Constants and variables</i>. If <tt>t</tt> ∈ <tt>Const</tt> or <tt>t</tt> ∈ <tt>Var</tt> then <tt>t</tt> is a <i><b>simple term</b></i>. </li>
  <li><i>Positional terms</i>. If <tt>t</tt> ∈ <tt>Const</tt> and <tt>t<sub>1</sub></tt>, ..., <tt>t<sub>n</sub></tt>, <tt>n≥0</tt>, are base terms then <tt>t(t<sub>1</sub> ... t<sub>n</sub>)</tt> is a <i><b>positional term</b></i>. 
  <p>
  Positional terms correspond to the usual terms and atomic formulas of
classical first-order logic [<a href="#ref-enderton01" title="">Enderton01</a>, <a href="#ref-mendelson97" title="">Mendelson97</a>].
  </p></li>
  <li><i>Terms with named arguments</i>. A <i><b>term with named arguments</b></i> is of the form <tt>t(s<sub>1</sub>-&gt;v<sub>1</sub> ... s<sub>n</sub>-&gt;v<sub>n</sub>)</tt>, where <tt>n≥0</tt>, <tt>t</tt> ∈ <tt>Const</tt> and <tt>v<sub>1</sub></tt>, ..., <tt>v<sub>n</sub></tt> are  base terms and <tt>s<sub>1</sub></tt>, ..., <tt>s<sub>n</sub></tt> are pairwise distinct symbols from the set <tt>ArgNames</tt>.
    <p>The constant <tt>t</tt> here represents a predicate or a function; <tt>s<sub>1</sub></tt>, ..., <tt>s<sub>n</sub></tt> represent argument names; and <tt>v<sub>1</sub></tt>, ..., <tt>v<sub>n</sub></tt> represent argument values. The argument names, <tt>s<sub>1</sub></tt>, ..., <tt>s<sub>n</sub></tt>,
are required to be pairwise distinct. Terms with named arguments are
like positional terms except that the arguments are named and their
order is immaterial. Note that a term of the form <tt>f()</tt> is, trivially, both a positional term and a term with named arguments. </p>
    <p>
Terms with named arguments are introduced to support exchange of languages
that permit argument positions of predicates and functions to be named
(in which case the order of the arguments does not matter).
    </p>
  </li>
  <li>  
     <i>List terms</i>. There are two kinds of list terms: <em>open</em> and <em>closed</em>.  
     <ul>     
       <li>
	 A <i><b>closed list</b></i> has the form <tt>List(t</tt><sub>1</sub> ... <tt>t</tt><sub>m</sub><tt>)</tt>, where <tt>m≥0</tt> and <tt>t</tt><sub>1</sub>, ..., <tt>t</tt><sub>m</sub> are terms.  
       </li>
       <li>       
	  An <i><b>open list</b></i> (or a list with a tail) has the form
	  <tt>OpenList(t</tt><sub>1</sub> ... <tt>t</tt><sub>m</sub> <tt>t)</tt>, where <tt>m&gt;0</tt> and <tt>t</tt><sub>1</sub>, ..., <tt>t</tt><sub>m</sub>, <tt>t</tt> are terms. Open lists are usually written using the following: <tt>List(t</tt><sub>1</sub> ... <tt>t</tt><sub>m</sub> <tt>|</tt> <tt>t)</tt>.
	  <p>
	     The last argument, <tt>t</tt>, represents the tail of the list and so it is normally a list as well. However, the syntax does not restrict <tt>t</tt> in any way: it could be an integer, a variable, another list, or, in fact, any term. An example is <tt>List(1 2 | 3)</tt>. This is not an ordinary list, where the last argument, <tt>3</tt>, would represent the tail of a list (and thus would also be a list, which <tt>3</tt> is not). Such general open lists correspond to Lisp's dotted lists [<a href="#ref-steele90" title="">Steele90</a>].
Note that they can be the result of instantiating an open list with a
variable in the tail, hence are hard to avoid. For instance, <tt>List(1 2 | 3)</tt> is <tt>List(1 2 |&nbsp;?X)</tt>, where the variable <tt>?X</tt> is replaced with <tt>3</tt>.
	  </p>
       </li>
     </ul>
     <p>
        A closed list of the form <tt>List()</tt> (i.e., a list in which <tt>m=0</tt>, corresponding to Lisp's <tt>nil</tt>) is called the <i><b>empty list</b></i>. 
     </p>
     <p>
     </p>
  </li>
  <li><i>Equality terms</i>.  <tt>t&nbsp;=&nbsp;s</tt> is an <i><b>equality term</b></i>, if <tt>t</tt> and <tt>s</tt> are base terms. </li>
  <li><i>Class membership terms</i> (or just <i>membership terms</i>). <tt>t#s</tt> is a <i><b>membership term</b></i> if <tt>t</tt> and <tt>s</tt> are base terms. </li>
  <li><i>Subclass terms</i>. <tt>t##s</tt> is a <i><b>subclass term</b></i> if <tt>t</tt> and <tt>s</tt> are base terms.
  </li>
  <li><i>Frame terms</i>. <tt>t[p<sub>1</sub>-&gt;v<sub>1</sub> ... p<sub>n</sub>-&gt;v<sub>n</sub>]</tt> is a <i><b>frame term</b></i> (or simply a <i><b>frame</b></i>) if <tt>t</tt>, <tt>p<sub>1</sub></tt>, ..., <tt>p<sub>n</sub></tt>, <tt>v<sub>1</sub></tt>, ..., <tt>v<sub>n</sub></tt>, <tt>n ≥ 0</tt>, are base terms.
    <p>
    Membership, subclass, and frame terms are used to describe objects and class hierarchies.
    </p>
  </li>
  <li>  
    <i>Externally defined terms.</i> If <tt>t</tt> is a positional or a named-argument term then <tt>External(t)</tt> is an <i><b>externally defined term</b></i>.
  <p>
External terms are used for representing built-in functions and
predicates as well as "procedurally attached" terms or predicates,
which might exist in various rule-based systems, but are not specified
by RIF. </p>
  </li>
</ol>
<p>Observe that the argument names of frame terms, <tt>p<sub>1</sub></tt>, ..., <tt>p<sub>n</sub></tt>,
are base terms and so, as a special case, can be variables. In
contrast, terms with named arguments can use only the symbols from <tt>ArgNames</tt> to represent their argument names. They cannot be constants from <tt>Const</tt> or variables from <tt>Var</tt>.
The reason for not allowing variables for those is to control the
complexity of unification, which is used by several inference
mechanisms of first-order logic.
</p><p><br>
<b>Example 2</b> (Terms)
</p><p>a. Positional term:   <tt>"http://example.com/ex1"^^rif:iri(1 "http://example.com/ex2"^^rif:iri(?X 5) "abc")</tt>  
</p><p>b. Term with named arguments: <tt>"http://example.com/Person"^^rif:iri(id-&gt;"http://example.com/John"^^rif:iri
"age"^^rif:local-&gt;?X "spouse"^^rif:local-&gt;?Y)</tt>
</p><p>c. Frame term: <tt>"http://example.com/John"^^rif:iri["age"^^rif:local-&gt;?X "spouse"^^rif:local-&gt;?Y]</tt>
</p><p>d. Lists
</p><p>- Empty list:  <tt>List()</tt> 
</p><p>- Closed list with variable inside:  <tt>List("a"^^xs:string&nbsp;?Y "c"^^xs:string)</tt>  
</p><p>- Open list with variables:  <tt>List("a"^^xs:string&nbsp;?Y "c"^^xs:string |&nbsp;?Z)</tt>  
</p><p>- Equality term with lists inside:  <tt>List(Head | Tail) = List("a"^^xs:string&nbsp;?Y "c"^^xs:string)</tt>  
</p><p>- Nested list:  <tt>List("a"^^xs:string List(?X "b"^^xs:string) "c"^^xs:string)</tt>  
</p><p><br> 
e. Classification terms
</p><p>- Membership: <tt>?X #&nbsp;?Y</tt>
</p><p>- Subclass:   <tt>?X ## "http://example.com/ex1"^^rif:iri(?Y)</tt>
</p><p>- Membership: <tt>"http://example.com/John"^^rif:iri # "http://example.com/Person"^^rif:iri</tt>
</p><p>- Subclass:   <tt>"http://example.com/Student"^^rif:iri ## "http://example.com/Person"^^rif:iri</tt>
</p><p><br> 
f. External term:  <tt>External(pred:numeric-greater-than(?diffdays 10)))</tt>
</p><p><br>
<span id="sec-formulas" class="anchor"></span>
</p>
<a name="Formulas"></a><h4> <span class="mw-headline">2.3  Formulas </span></h4>
<p>RIF-BLD distinguishes certain subsets of the set <tt>Const</tt> of symbols, including the subset of <i>predicate symbols</i> and <i>function symbols</i>. Section <a href="#sec-well-formed" title="">Well-formed Formulas</a> gives more details, but we do not need those details yet.
</p><p><span id="def-bld-atomic-formula" class="anchor"></span> 
<b>Definition (Atomic Formula)</b>.
Any term (positional or with named arguments) of the form <tt>p(...)</tt>, where <tt>p</tt> is a predicate symbol, is also an <i><b>atomic formula</b></i>. Equality, membership, subclass, and frame terms are also atomic formulas. An externally defined term of the form <tt>External(φ)</tt>, where <tt>φ</tt> is an atomic formula, is also an atomic formula, called an <i><b>externally defined</b></i> atomic formula.
&nbsp;&nbsp;☐
</p><p>Note that simple terms (constants and variables) are <i>not</i> formulas.
</p><p>More general formulas are constructed from atomic formulas with the help of logical connectives.
</p><p><span id="def-bld-formula" class="anchor"></span> 
<b>Definition (Formula)</b>.
A <i><b>formula</b></i> can have several different forms and is defined as follows:
</p>
<ol>
  <li>
    <i>Atomic</i>: If <tt>φ</tt>  is an atomic formula then it is also a formula.
  </li>
  <li>
    <i><span id="def-bld-condition">Condition formula</span></i>: A <i><b>condition formula</b></i> is either an atomic formula or a formula that has one of the following forms:
    <ul>
      <li>
        <i>Conjunction</i>: If <tt>φ<sub>1</sub></tt>, ..., <tt>φ<sub>n</sub></tt>,  <tt>n ≥ 0</tt>, are condition formulas then so is <tt>And(φ<sub>1</sub> ... φ<sub>n</sub>)</tt>, called a <i>conjunctive</i> formula. As a special case, <tt>And()</tt> is allowed and is treated as a tautology, i.e., a formula that is always true. 
      </li>
      <li>
        <i>Disjunction</i>: If <tt>φ<sub>1</sub></tt>, ..., <tt>φ<sub>n</sub></tt>, <tt>n ≥ 0</tt>, are condition formulas then so is <tt>Or(φ<sub>1</sub> ... φ<sub>n</sub>)</tt>, called a <i>disjunctive</i> formula. As a special case, <tt>Or()</tt> is permitted and is treated as a contradiction, i.e., a formula that is always false. 
      </li>
      <li>
        <i>Existentials</i>: If <tt>φ</tt>  is a condition formula and <tt>?V<sub>1</sub></tt>, ..., <tt>?V<sub>n</sub></tt>, <tt>n&gt;0</tt>, are distinct variables then <tt>Exists&nbsp;?V<sub>1</sub> ...&nbsp;?V<sub>n</sub>(φ)</tt> is an <i>existential</i> formula. 
      </li>
    </ul> 
    <p>
Condition formulas are intended to be used inside the premises of
rules. Next we define the notions of rule implications, universal
rules, universal facts, groups (i.e., sets of rules and facts), and
documents. </p>
  </li>
  <li>
    <i>Rule implication</i>: <tt>φ&nbsp;:- ψ</tt> is a formula, called <i>rule implication</i>, if:
    <ul>    
      <li>
        <tt>φ</tt>  is an atomic formula or a <i>conjunction</i> of atomic formulas,
      </li>
      <li>
	<tt>ψ</tt>  is a condition formula, and
      </li>
      <li>      
	none of the atomic formulas in <tt>φ</tt>  is an externally defined term (i.e., a term of the form <tt>External(...)</tt>). Note: external terms <i>can</i> occur in the <i>arguments</i> of atomic formulas in the rule conclusion. For instance, <tt>p(func:numeric-add(?X,"2"^^xsd:integer))&nbsp;:- q(?X)</tt>.
      </li>
    </ul>
    <div class="atRiskNote">
<p><strong id="atRisk2">Feature At Risk #2: Equality in the rule conclusion (<tt>φ</tt> in
  the above)</strong></p>
<p class="atRiskNoteHead">Note: This feature is <a href="http://www.w3.org/2005/10/Process-20051014/tr#cfi" class="external text" title="http://www.w3.org/2005/10/Process-20051014/tr#cfi">"at risk"</a> and may be removed from this specification based on feedback.   Please send feedback to <a href="mailto:public-rif-comments@w3.org" class="external text" title="mailto:public-rif-comments@w3.org">public-rif-comments@w3.org</a>.</p>
<p></p>
</div>
  </li>
  <li>
    <i>Universal rule</i>: If <tt>φ</tt>  is a rule implication and <tt>?V<sub>1</sub></tt>, ..., <tt>?V<sub>n</sub></tt>, <tt>n&gt;0</tt>, are distinct variables then <tt>Forall&nbsp;?V<sub>1</sub> ...&nbsp;?V<sub>n</sub>(φ)</tt> is a formula, called a <i>universal rule</i>. It is required that all the <i>free</i> variables in <tt>φ</tt>  occur among the variables <tt>?V<sub>1</sub> ...&nbsp;?V<sub>n</sub></tt> in the quantification part. An occurrence of a variable <tt>?v</tt> is <i>free</i> in <tt>φ</tt> if it is not inside a substring of the form <tt>Q&nbsp;?v (ψ)</tt> of <tt>φ</tt>, where <tt>Q</tt> is a quantifier (<tt>Forall</tt> or <tt>Exists</tt>) and <tt>ψ</tt> is a formula.  Universal rules will also be referred to as <i><b><span id="def-rif-bld-rule" class="anchor">RIF-BLD rules</span></b></i>.
  </li>
  <li>
    <i>Universal fact</i>: If <tt>φ</tt>  is an atomic formula and <tt>?V<sub>1</sub></tt>, ..., <tt>?V<sub>n</sub></tt>, <tt>n&gt;0</tt>, are distinct variables then
     <tt>Forall&nbsp;?V<sub>1</sub> ...&nbsp;?V<sub>n</sub>(φ)</tt> is a formula, called a <i>universal fact</i>, provided that all the free variables in  <tt>φ</tt>  occur among the variables <tt>?V<sub>1</sub> ...&nbsp;?V<sub>n</sub></tt>.
    <p>
      Universal facts are often considered to be rules without premises.
    </p>
  </li>
  <li>
    <i>Group</i>: If <tt>φ<sub>1</sub></tt>, ..., <tt>φ<sub>n</sub></tt> are RIF-BLD rules, universal facts, variable-free rule implications, variable-free atomic formulas, <i>or</i> group formulas then <tt>Group(φ<sub>1</sub> ... φ<sub>n</sub>)</tt> is a <i>group formula</i>. As a special case, the empty group formula, <tt>Group()</tt>, is allowed and is treated as a tautology, i.e., a formula that is always true.
    <p>
       Non-empty group formulas are used to represent sets of rules and facts. Note that some of the <tt>φ<sub>i</sub></tt>'s can be group formulas themselves, which means that groups can be nested. 
    </p>
  </li>
  <li>  
    <i>Document</i>: An expression of the form <tt>Document(<em>directive<sub>1</sub></em> ... <em>directive<sub>n</sub></em> Γ)</tt> is a <i>RIF-BLD document formula</i> (or simply a <i>document formula</i>), if
    <ul>    
      <li>      
	<tt>Γ</tt> is an optional group formula; it is called the group formula <span id="def-associated-group"><i>associated</i></span> with the document.
      </li>
      <li>
	<tt><em>directive<sub>1</sub></em></tt>, ..., <tt><em>directive<sub>n</sub></em></tt> is an optional sequence of <span id="def-directives"><em>directives</em></span>. A directive can be a <i>base directive</i>, a <i>prefix directive</i> or an <i>import directive</i>. 
      <ul>
	<li>	
	  A <i><b>base directive</b></i> has the form <tt>Base(&lt;iri&gt;)</tt>, where <tt>iri</tt> is a Unicode string in the form of an absolute IRI [<a href="#ref-rfc-3987" title="">RFC-3987</a>].
	  <p>
	    The <tt>Base</tt> directive defines a syntactic shortcut for expanding relative IRIs into full IRIs, as described in Section <a href="http://www.w3.org/2005/rules/wiki/DTB#sec-constants" title="DTB">Constants, Symbol Spaces, and Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].  
	  </p>
	</li>
	<li>	
	   A <i><b>prefix directive</b></i> has the form <tt>Prefix(p &lt;v&gt;)</tt>, where <tt>p</tt> is an alphanumeric string that serves as the prefix name and <tt>v</tt> is an expansion for <tt>p</tt>
-- a Unicode sequence of characters that forms an IRI. (An alphanumeric
string is a sequence of ASCII characters, where each character is a
letter, a digit, or an underscore "_", and the first character is a
letter.) <p>
	      Like the <tt>Base</tt> directive, the <tt>Prefix</tt> directives define shorthands to allow more concise representation of constants that come from the symbol space <tt>rif:iri</tt> (we will call such constants <tt>rif:iri</tt> <i><b>constants</b></i>). This mechanism is explained in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], Section <a href="http://www.w3.org/2005/rules/wiki/DTB#sec-constants" title="DTB">Constants, Symbol Spaces, and Datatypes</a>.
	   </p>
	</li>
	<li>      
	  An <i><b>import directive</b></i> can have one of these two forms: <tt>Import(&lt;loc&gt;)</tt> or <tt>Import(&lt;loc&gt; &lt;p&gt;)</tt>. Here <tt>loc</tt> is a Unicode sequence of characters that forms an IRI and <tt>p</tt> is another Unicode sequence of characters. The constant <tt>loc</tt> represents the location of another document to be imported; it is called the <span id="ref-locator" class="anchor"><i><b>locator</b></i></span> of the imported document. The argument <tt>p</tt> is called the <i>profile of import</i>; it has the form of a Unicode character sequence in the form of an IRI -- see [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>].
	  <p>
	    Section <a href="#sec-bld-direct-semantics" title="">Direct Specification of RIF-BLD Semantics</a> of this document defines the semantics for the directive <tt>Import(&lt;loc&gt;)</tt> only. The two-argument directive, <tt>Import(&lt;loc&gt; &lt;p&gt;)</tt>,
is intended for importing non-RIF-BLD documents, such as rules from
other RIF dialects, RDF data, or OWL ontologies. The profile, <tt>p</tt>,
indicates what kind of entity is being imported and under what
semantics (for instance, the various RDF entailment regimes have
different profiles). The semantics of <tt>Import(&lt;loc&gt; &lt;p&gt;)</tt> (for various <tt>p</tt>) are expected to be given by other specifications on a case-by-case basis. For instance, [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>] defines the semantics for the profiles that are recommended for importing RDF and OWL.
	  </p>
	</li>
      </ul>
      <p>
        Note that although <tt>Base</tt>, <tt>Prefix</tt>, and <tt>Import</tt> all use symbols of the form &lt;iri&gt; to indicate the connection of these symbols to IRIs, these symbols are <em>not</em> <tt>rif:iri</tt> constants, as semantically they are interpreted in a way that is quite different from constants.
      </p>
      <p>
        A document formula can contain at most one <tt>Base</tt> directive. The <tt>Base</tt> directive, if present, must be first, followed by any number of <tt>Prefix</tt> directives, followed by any number of <tt>Import</tt> directives.
      </p>
      </li>
    </ul>
  </li>
</ol>
<p>
  In the definition of a formula, the component formulas <tt>φ</tt>, <tt>φ<sub>i</sub></tt>, <tt>ψ<sub>i</sub></tt>, and <tt>Γ</tt>  are said to be <span id="def-subformula" class="anchor"><i><b>subformulas</b></i></span> of the respective formulas (condition, rule, group, etc.) that are built using these components. &nbsp;&nbsp;☐
</p>
<p><br>
</p><p><span id="sec-formal-syntax-metadata" class="anchor"></span>
</p>
<a name="RIF-BLD_Annotations_in_the_Presentation_Syntax"></a><h4> <span class="mw-headline">2.4  RIF-BLD Annotations in the Presentation Syntax </span></h4>
<p>RIF-BLD allows every term and formula (including terms and formulas
that occur inside other terms and formulas) to be optionally preceded
by an <i><b>annotation</b></i> of the form <tt>(* id φ *)</tt>, where <tt>id</tt> is a <tt><a href="http://www.w3.org/2005/rules/wiki/DTB#rif-iri-space" title="DTB">rif:iri</a></tt> constant and <tt>φ</tt> is a frame formula or a conjunction of frame formulas. Both items inside the annotation are optional. The <tt>id</tt> part represents the identifier of the term or formula to which the annotation is attached and <tt>φ</tt> is the metadata part of the annotation. RIF-BLD does not impose any restrictions on <tt>φ</tt> apart from what is stated above. This means that it may include variables, function symbols, constants from the symbol space <tt><a href="http://www.w3.org/2005/rules/wiki/DTB#rif-local-space" title="DTB">rif:local</a></tt> (often referred to as <i><b>local</b></i> or <tt>rif:local</tt> <i><b>constants</b></i>), and so on.   
</p><p>Document formulas with and without annotations will be referred to as <i><b><span id="def-rif-bld-document">RIF-BLD documents</span></b></i>.
</p><p>The following convention is used to avoid a syntactic ambiguity
with respect to annotations. The annotation scoping convention
associates each annotation to the largest term or formula it precedes.
For instance, in <tt>(* id φ *) t[w -&gt; v]</tt> the metadata annotation could be attributed to the term <tt>t</tt> or to the entire frame <tt>t[w -&gt; v]</tt>. The convention specifies that the above annotation is considered to be syntactically attached to the entire frame. Yet, since <tt>φ</tt> can be a conjunction, some conjuncts can be used to provide metadata targeted to the object part, <tt>t</tt>, of the frame. For instance, <tt>(*
And(_foo[meta_for_frame-&gt;"this is an annotation for the entire
frame"] _bar[meta_for_object-&gt;"this is an annotation for t"
meta_for_property-&gt;"this is an annotation for w"]) *) t[w -&gt; v]</tt>. 
</p><p><br>
We suggest to use Dublin Core, RDFS, and OWL properties for metadata, along the lines of <a href="http://www.w3.org/TR/owl-ref/#Annotations" class="external text" title="http://www.w3.org/TR/owl-ref/#Annotations">Section 7.1</a> of [<a href="#ref-owl-reference" title="">OWL-Reference</a>]-- specifically <tt>owl:versionInfo</tt>, <tt>rdfs:label</tt>, <tt>rdfs:comment</tt>, <tt>rdfs:seeAlso</tt>, <tt>rdfs:isDefinedBy</tt>, <tt>dc:creator</tt>, <tt>dc:description</tt>, <tt>dc:date</tt>, and <tt>foaf:maker</tt>.
</p><p><span id="sec-well-formed" class="anchor"></span>
</p>
<a name="Well-formed_Formulas"></a><h4> <span class="mw-headline">2.5  Well-formed Formulas </span></h4>
<p>Not all formulas and thus not all documents are well-formed in RIF-BLD:
it is required that no constant appear in more than one context. What this means precisely is explained below.
</p><p>The set of all constant symbols, <tt>Const</tt>, is partitioned into the following subsets:
</p>
<ul>
  <li>A subset of individuals.
    <p>The symbols in <tt>Const</tt> that belong to the symbol spaces of <a href="http://www.w3.org/2005/rules/wiki/DTB#sec-data-types" title="DTB">Datatypes</a> are required to be individuals.</p>
  </li>
  <li>A subset of plain (i.e., non-external) function symbols.
  </li>
  <li>A subset for external function symbols.
  </li>
  <li>A subset of plain predicate symbols.
  </li>
  <li>A subset for external predicate symbols.
  </li>
</ul>
<p>The above subsets do not differentiate between positional and named
argument symbols. Also, as seen from the following definitions, these
subsets are not specified explicitly but, rather, are inferred from the
occurrences of the symbols.
</p><p><br>
<span id="def-bld-context" class="anchor"></span> 
<b>Definition (Context of a symbol)</b>.
The <i><b>context of an occurrence</b></i> of a symbol, <tt>s∈Const</tt>, in a formula, <tt>φ</tt>,  is determined as follows:
</p>
<ul>
  <li>
     If <tt>s</tt> occurs as a predicate of the form <tt>s(...)</tt> (positional or named-argument) in an atomic <a href="#def-subformula" title="">subformula</a> of <tt>φ</tt> then <tt>s</tt> occurs in the <i>context of a (plain) predicate symbol</i>.     
  </li>
  <li>
     If <tt>s</tt> occurs as a function symbol in a non-subformula term of the form <tt>s(...)</tt> then <tt>s</tt> occurs in the <i>context of a (plain) function symbol</i>.
  </li>
  <li>  
    If <tt>s</tt> occurs as a predicate in an atomic subformula <tt>External(s(...))</tt> then <tt>s</tt> occurs in the <i>context of an external predicate symbol</i>.
  </li>
  <li>  
    If <tt>s</tt> occurs as a function in a non-subformula term <tt>External(s(...))</tt> then <tt>s</tt> occurs in the <i>context of an external function symbol</i>.
  </li>
  <li>  
     If <tt>s</tt> occurs in any other context (in a frame: <tt>s[...]</tt>, <tt>...[s-&gt;...]</tt>, or <tt>...[...-&gt;s]</tt>; or in a positional/named-argument term: <tt>p(...s...)</tt>, <tt>q(...-&gt;s...)</tt>), it is said to occur as an <i>individual</i>. &nbsp;&nbsp;☐
  </li>
</ul>
<p><span id="def-bld-imported-doc" class="anchor"></span> 
<b>Definition (Imported document).</b>
Let <tt>Δ</tt> be a document formula and <tt>Import(<i>loc</i>)</tt> be one of its import directives, where <i>loc</i> is a <a href="#ref-locator" title="">locator</a> of another document formula, <tt>Δ'</tt>.  We say that <tt>Δ'</tt> is <i><b>directly imported</b></i> into <tt>Δ</tt>.
</p><p>A document formula <tt>Δ'</tt> is said to be <i><b>imported</b></i> into
<tt>Δ</tt> if it is either directly imported into <tt>Δ</tt> or it is imported (directly or not) into some other formula that is directly imported into <tt>Δ</tt>. &nbsp; &nbsp; ☐  
</p><p>The above definition deals only with one-argument import
directives, since only such directives can be used to import other
RIF-BLD documents.
Two-argument import directives are provided to enable import of other
types of documents, and their semantics are supposed to be covered by
other specifications, such as [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>].
</p><p><br>
<span id="def-bld-wff" class="anchor"></span> 
<b>Definition (Well-formed formula)</b>.
A formula <tt>φ</tt>  is <i><b>well-formed</b></i> iff:
</p>
<ul>
  <li>
    every constant symbol (whether coming from the symbol space <tt><a href="http://www.w3.org/2005/rules/wiki/DTB#rif-local-space" title="DTB">rif:local</a></tt> or not) mentioned in <tt>φ</tt> occurs in exactly one <a href="#def-bld-context" title="">context</a>.
  </li>
  <li>  
    if <tt>φ</tt> is a document formula and <tt>Δ'<sub>1</sub></tt>, ..., <tt>Δ'<sub>k</sub></tt> are all of its imported documents, then every non-<tt>rif:local</tt> constant symbol mentioned in <tt>φ</tt> or any of the imported <tt>Δ'<sub>i</sub></tt>s must occur in exactly one context (in all of the <tt>Δ'<sub>i</sub></tt>s).
  </li>
  <li>
    whenever a formula contains a term or a subformula of the form <tt>External(t)</tt>, <tt>t</tt> must be an instance of a schema in the coherent set of external schemas (Section <a href="http://www.w3.org/2005/rules/wiki/DTB#app-external-schema" title="DTB">Schemas for Externally Defined Terms</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]) associated with the <a href="#def-bld-lang" title="">language of RIF-BLD</a>.
  </li>
  <li>
    if <tt>t</tt> is an instance of a schema in the coherent set of external schemas associated with the language then <tt>t</tt> can occur only as <tt>External(t)</tt>, i.e., as an external term or atomic formula. &nbsp;&nbsp;☐
  </li>
</ul>
<p><br>
<span id="def-bld-lang" class="anchor"></span> 
<b>Definition (Language of RIF-BLD)</b>.
The <i><b>language of RIF-BLD</b></i> consists of the set of all well-formed formulas and is determined by:
</p>
<ul><li> the alphabet of the language and
</li><li> a  set of <a href="http://www.w3.org/2005/rules/wiki/DTB#def-external-schema-set" title="DTB">coherent external schemas</a>, which determine the available built-ins and other externally defined predicates and functions. &nbsp;&nbsp;☐
</li></ul>
<p><br>
<span id="sec-concrete-syntax" class="anchor"></span>
</p>
<a name="EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-BLD_.28Informative.29"></a><h4> <span class="mw-headline">2.6  EBNF Grammar for the Presentation Syntax of RIF-BLD (Informative) </span></h4>
<p>Until now, we have been using mathematical English to specify the
syntax of RIF-BLD. Tool developers, however, may prefer EBNF notation,
which provides a more succinct view of the syntax. Several points
should be kept in mind regarding this notation. </p>
<ul><li> The syntax of first-order logic is not context-free, so EBNF
cannot capture the syntax of RIF-BLD precisely. For instance, it cannot
capture the <a href="#sec-well-formed" title="">well-formedness conditions</a>,
i.e., the requirement that each symbol in RIF-BLD can occur in at most
one context. As a result, the EBNF grammar defines a strict <i>superset</i> of RIF-BLD: not all formulas that are derivable using the EBNF grammar are well-formed formulas in RIF-BLD. 
</li><li> The EBNF grammar does not address all details of how constants (defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>])
and variables are represented, and it is not sufficiently precise about
the delimiters and escape symbols. White space is informally used as a
delimiter, and is implied in productions that use Kleene star. For
instance, <tt>TERM*</tt> is to be understood as <tt>TERM&nbsp;TERM&nbsp;...&nbsp;TERM</tt>,
where each space abstracts from one or more blanks, tabs, newlines,
etc. This is so because RIF's presentation syntax is a tool for
specifying the semantics and for illustration of the main RIF concepts
through examples. It is <i>not</i> intended as a concrete syntax for a rule language. RIF defines a concrete syntax only for <i>exchanging</i> rules, and that syntax is XML-based, obtained as a refinement and serialization of the presentation syntax.
</li><li> For all the above reasons, the EBNF grammar is <i>not normative</i>. Recall from the <a href="#sec-bld-direct-syntax" title="">opening paragraph</a>, however, that the RIF-BLD presentation syntax as specified in mathematical English is normative.
</li></ul>
<p>The EBNF for the RIF-BLD presentation syntax is given as follows,
showing the entire (top-down) context of its three parts for rules,
conditions, and annotations.
</p><p><span id="part-rule-language" class="anchor"></span>
<b>Rule Language:</b>
</p>
<pre>  Document      &nbsp;::= IRIMETA? 'Document' '(' Base? Prefix* Import* Group? ')'
  Base          &nbsp;::= 'Base' '(' ANGLEBRACKIRI ')'
  Prefix        &nbsp;::= 'Prefix' '(' Name ANGLEBRACKIRI ')'
  Import        &nbsp;::= IRIMETA? 'Import' '(' LOCATOR PROFILE? ')'
  Group         &nbsp;::= IRIMETA? 'Group' '(' (RULE | Group)* ')'
  RULE          &nbsp;::= (IRIMETA? 'Forall' Var+ '(' CLAUSE ')') | CLAUSE
  CLAUSE        &nbsp;::= Implies | ATOMIC
  Implies       &nbsp;::= IRIMETA? (ATOMIC | 'And' '(' ATOMIC* ')') ':-' FORMULA
  LOCATOR       &nbsp;::= ANGLEBRACKIRI
  PROFILE       &nbsp;::= ANGLEBRACKIRI
</pre>
<p><span id="part-condition-language" class="anchor"></span>
<b>Condition Language:</b>
</p>
<pre>  FORMULA       &nbsp;::= IRIMETA? 'And' '(' FORMULA* ')' |
                     IRIMETA? 'Or' '(' FORMULA* ')' |
                     IRIMETA? 'Exists' Var+ '(' FORMULA ')' |
                     ATOMIC |
                     IRIMETA? 'External' '(' Atom ')'
  ATOMIC        &nbsp;::= IRIMETA? (Atom | Equal | Member | Subclass | Frame)
  Atom          &nbsp;::= UNITERM
  UNITERM       &nbsp;::= Const '(' (TERM* | (Name '-&gt;' TERM)*) ')'
  Equal         &nbsp;::= TERM '=' TERM
  Member        &nbsp;::= TERM '#' TERM
  Subclass      &nbsp;::= TERM '##' TERM
  Frame         &nbsp;::= TERM '[' (TERM '-&gt;' TERM)* ']'
  TERM          &nbsp;::= IRIMETA? (Const | Var | Expr | List | 'External' '(' Expr ')')
  Expr          &nbsp;::= UNITERM
  List          &nbsp;::= 'List' '(' TERM* ')' | 'List' '(' TERM+ '|' TERM ')'
  Const         &nbsp;::= '"' UNICODESTRING '"^^' SYMSPACE | CONSTSHORT
  Name          &nbsp;::= UNICODESTRING
  Var           &nbsp;::= '?' UNICODESTRING
  SYMSPACE      &nbsp;::= ANGLEBRACKIRI | CURIE
</pre>
<p><span id="part-annotations" class="anchor"></span>
<b>Annotations:</b>
</p>
<pre>  IRIMETA       &nbsp;::= '(*' IRICONST? (Frame | 'And' '(' Frame* ')')? '*)'
</pre>
<p>The following subsections explain and exemplify these parts, starting with the basic language of positive conditions.
</p><p><br>
<span id="sec-ebnf-condition-language" class="anchor"></span> 
</p>
<a name="EBNF_for_the_Condition_Language"></a><h5> <span class="mw-headline">2.6.1  EBNF for the Condition Language </span></h5>
<p>The Condition Language represents formulas that can be used in the
premises of RIF-BLD rules (also called rule bodies). The EBNF grammar
for a superset of the RIF-BLD condition language is shown in the above <a href="#part-condition-language" title="">conditions part</a>.
</p><p>The production rule for the non-terminal <tt>FORMULA</tt> represents <i>RIF condition formulas</i> (defined earlier). The connectives <tt>And</tt> and <tt>Or</tt> define conjunctions and disjunctions of conditions, respectively. <tt>Exists</tt> introduces existentially quantified variables. Here <tt>Var+</tt> stands for the list of variables that are free in <tt>FORMULA</tt>. RIF-BLD conditions permit only existential variables. A RIF-BLD <tt>FORMULA</tt> can also be an <tt>ATOMIC</tt> term, i.e. an <tt>Atom</tt>, <tt>External</tt> <tt>Atom</tt>, <tt>Equal</tt>, <tt>Member</tt>, <tt>Subclass</tt>, or <tt>Frame</tt>. A <tt>TERM</tt> can be a constant, variable, <tt>Expr</tt>, <tt>List</tt>, or <tt>External</tt> <tt>Expr</tt>.
</p><p>The RIF-BLD presentation syntax does not commit to any
particular vocabulary and permits arbitrary Unicode strings in constant
symbols, argument names, and variables. Constant symbols can have this
form: <tt>"UNICODESTRING"^^SYMSPACE</tt>, where <tt>SYMSPACE</tt> is an <tt>ANGLEBRACKIRI</tt> or <tt>CURIE</tt> that represents the identifier of the symbol space of the constant, and <tt>UNICODESTRING</tt> is a Unicode string from the lexical space of that symbol space. <tt>ANGLEBRACKIRI</tt> and <tt>CURIE</tt> are defined in Section <a href="http://www.w3.org/2005/rules/wiki/DTB#sec-shortcuts-constants" title="DTB">Shortcuts for Constants in RIF's Presentation Syntax</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. Constant symbols can also have several shortcut forms, which are represented by the non-terminal <tt>CONSTSHORT</tt>. These shortcuts are also defined in the same section of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. One of them is the <tt>CURIE</tt> shortcut, which is extensively used in the examples in this document.
Names are Unicode character sequences. Variables are composed of <tt>UNICODESTRING</tt> symbols prefixed with a <tt>?</tt>-sign.
</p><p>Equality, membership, and subclass terms are self-explanatory. An <tt>Atom</tt> and <tt>Expr</tt>
(expression) can either be positional or have named arguments. A frame
term is a term composed of an object identifier and a collection of
attribute-value pairs. The term <tt>External</tt>(<tt>Atom</tt>) is a call to an externally defined predicate. Likewise, <tt>External</tt>(<tt>Expr</tt>) is a call to an externally defined function.
</p><p><br>
<span id="ex-rif-bld-cond-pres-syntax" class="anchor">
<b>Example 3</b> (RIF-BLD conditions).
</span>
</p><p>This example shows conditions that are composed of atoms,
expressions, equalities with lists, frames, and existentials. In frame
formulas, variables are shown in the positions of object identifiers,
object properties, and property values. For brevity, we use the
shortcut CURIE notation <tt>prefix:suffix</tt> for constant symbols defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. This is understood as a shorthand for an IRI obtained by concatenation of the <tt>prefix</tt>  definition and <tt>suffix</tt>. Thus, if <tt>bks</tt> is a prefix that expands into <tt>http://example.com/books#</tt> then <tt>bks:LeRif</tt> is an abbreviation for <tt>"http://example.com/books#LeRif"^^rif:iri</tt>. 
</p>
<pre>Prefix(bks  &lt;http://example.com/books#&gt;)
Prefix(auth &lt;http://example.com/authors#&gt;)
Prefix(cpt  &lt;http://example.com/concepts#&gt;)

</pre>
<p>Positional terms:
</p>
<pre>  cpt:book(auth:rifwg bks:LeRif)
  Exists&nbsp;?X (cpt:book(?X bks:LeRif))

</pre>
<p>Terms with named arguments:
</p>
<pre>  cpt:book(cpt:author-&gt;auth:rifwg  cpt:title-&gt;bks:LeRif)
  Exists&nbsp;?X (cpt:book(cpt:author-&gt;?X cpt:title-&gt;bks:LeRif))

</pre>
<p>Equalities with list terms:
</p>
<pre> &nbsp;?L = List(?X&nbsp;?Y&nbsp;?X)
  List(?Head |&nbsp;?Tail) = List("a"^^rif:local&nbsp;?Y "c"^^rif:local)

</pre>
<p>Frames:
</p>
<pre>  bks:wd1[cpt:author-&gt;auth:rifwg cpt:title-&gt;bks:LeRif]
  Exists&nbsp;?X (bks:wd2[cpt:author-&gt;?X  cpt:title-&gt;bks:LeRif])
  Exists&nbsp;?X (And (bks:wd2#cpt:book  bks:wd2[cpt:author-&gt;?X  cpt:title-&gt;bks:LeRif]))
  Exists&nbsp;?I&nbsp;?X (?I[cpt:author-&gt;?X  cpt:title-&gt;bks:LeRif])
  Exists&nbsp;?I&nbsp;?X (And (?I#cpt:book&nbsp;?I[cpt:author-&gt;?X  cpt:title-&gt;bks:LeRif]))
  Exists&nbsp;?S (bks:wd2[cpt:author-&gt;auth:rifwg&nbsp;?S-&gt;bks:LeRif])
  Exists&nbsp;?X&nbsp;?S (bks:wd2[cpt:author-&gt;?X&nbsp;?S-&gt;bks:LeRif])
  Exists&nbsp;?I&nbsp;?X&nbsp;?S (And (?I#cpt:book &nbsp;?I[author-&gt;?X&nbsp;?S-&gt;bks:LeRif]))
</pre>
<p><br>
</p><p><span id="sec-ebnf-rule-language" class="anchor"></span>
</p>
<a name="EBNF_for_the_Rule_Language"></a><h5> <span class="mw-headline">2.6.2  EBNF for the Rule Language </span></h5>
<p>The presentation syntax for RIF-BLD rules is based on the syntax in Section <a href="#sec-ebnf-condition-language" title="">EBNF for RIF-BLD Condition Language</a> with the productions shown in the above <a href="#part-rule-language" title="">rules part</a>.
</p><p><span id="document-preamble" class="anchor"></span>
A RIF-BLD <tt>Document</tt> consists of an optional <tt>Base</tt>, followed by any number of <tt>Prefix</tt>es, followed by any number of <tt>Import</tt>s, followed by an optional <tt>Group</tt>.
<tt>Base</tt> and <tt>Prefix</tt> serve as shortcut mechanisms for IRIs.
<tt>IRI</tt> has the form of an internationalized resource identifier as defined by [<a href="#ref-rfc-3987" title="">RFC-3987</a>].
An <tt>Import</tt> indicates the location of a document to be imported and an optional profile.
A RIF-BLD <tt>Group</tt> is a collection of
any number of <tt>RULE</tt> elements along with any number of nested <tt>Group</tt>s.
</p><p>Rules are generated using <tt>CLAUSE</tt> elements. The <tt>RULE</tt>  production has two alternatives:
</p>
<ul><li> In the first, a <tt>CLAUSE</tt>  is in the scope of the <tt>Forall</tt> quantifier. In that case, all variables mentioned in  <tt>CLAUSE</tt> are required to also appear among the variables in the <tt>Var+</tt> sequence.
</li><li> In the second alternative, <tt>CLAUSE</tt> appears on its own. In that case, <tt>CLAUSE</tt> cannot have variables. 
</li></ul>
<p><tt>Var</tt>, <tt>ATOMIC</tt>, and <tt>FORMULA</tt> were defined as part of the syntax for positive conditions in Section <a href="#sec-ebnf-condition-language" title="">EBNF for RIF-BLD Condition Language</a>. In the <tt>CLAUSE</tt> production, an <tt>ATOMIC</tt> is what is usually called a <i>fact</i>. An <tt>Implies</tt> <i>rule</i> can have an <tt>ATOMIC</tt> or a conjunction of <tt>ATOMIC</tt> elements as its conclusion; it has a <tt>FORMULA</tt> as its premise. Note that, by the <a href="#def-bld-formula" title="">definition of formulas</a>, externally defined atoms (i.e., formulas of the form <tt>External(Atom)</tt>) are not allowed in the conclusion part of a rule (<tt>ATOMIC</tt> does not expand to <tt>External</tt>).
</p><p><br>
</p><p><span id="ex-rif-bld-rule-pres-syntax" class="anchor">
<b>Example 4</b> (RIF-BLD rules).
</span>
</p><p>This example shows a business rule borrowed from the document <a href="http://www.w3.org/2005/rules/wiki/UCR" title="UCR">RIF Use Cases and Requirements</a>:
</p>
<ul>
  <li>
    <em>
      If an item is perishable and it is delivered to John more than 10 days
      after the scheduled delivery date then the item will be rejected by him.
    </em>
  </li>
</ul>
<p>As before, for better readability we use the compact URI notation defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], Section <a href="http://www.w3.org/2005/rules/wiki/DTB#sec-constants" title="DTB">Constants, Symbol Spaces, and Datatypes</a>. Again, prefix directives are assumed in the preamble to the document.
Then, two versions of the main part of the document are given.
</p>
<pre>Prefix(ppl  &lt;http://example.com/people#&gt;)
Prefix(cpt  &lt;http://example.com/concepts#&gt;)
Prefix(func &lt;http://www.w3.org/2007/rif-builtin-function#&gt;)
Prefix(pred &lt;http://www.w3.org/2007/rif-builtin-predicate#&gt;)

</pre>
<p>a. Universal form:
</p>
<pre>   Forall&nbsp;?item&nbsp;?deliverydate&nbsp;?scheduledate&nbsp;?diffduration&nbsp;?diffdays (
        cpt:reject(ppl:John&nbsp;?item)&nbsp;:-
            And(cpt:perishable(?item)
                cpt:delivered(?item&nbsp;?deliverydate ppl:John)
                cpt:scheduled(?item&nbsp;?scheduledate)
               &nbsp;?diffduration = External(func:subtract-dateTimes(?deliverydate&nbsp;?scheduledate))
               &nbsp;?diffdays = External(func:days-from-duration(?diffduration))
                External(pred:numeric-greater-than(?diffdays 10)))
   )

</pre>
<p>b. Universal-existential form:
</p>
<pre>   Forall&nbsp;?item (
        cpt:reject(ppl:John&nbsp;?item )&nbsp;:-
            Exists&nbsp;?deliverydate&nbsp;?scheduledate&nbsp;?diffduration&nbsp;?diffdays (
                 And(cpt:perishable(?item)
                     cpt:delivered(?item&nbsp;?deliverydate ppl:John)
                     cpt:scheduled(?item&nbsp;?scheduledate)
                    &nbsp;?diffduration = External(func:subtract-dateTimes(?deliverydate&nbsp;?scheduledate))
                    &nbsp;?diffdays = External(func:days-from-duration(?diffduration))
                     External(pred:numeric-greater-than(?diffdays 10)))
            )
   )
</pre>
<p><br>
</p><p><span id="sec-ebnf-annotations" class="anchor"></span>
</p>
<a name="EBNF_for_Annotations"></a><h5> <span class="mw-headline">2.6.3  EBNF for Annotations </span></h5>
<p>The EBNF grammar production for RIF-BLD annotations is shown in the above <a href="#part-annotations" title="">annotations part</a>.
</p><p>As explained in Section <a href="#sec-formal-syntax-metadata" title="">RIF-BLD Annotations in the Presentation Syntax</a>, RIF-BLD formulas and terms can be prefixed with optional annotations, <tt>IRIMETA</tt>, for identification and metadata.
<tt>IRIMETA</tt> is represented using <tt>(*...*)</tt>-brackets
that contain an optional <tt>rif:iri</tt> constant, <tt>IRICONST</tt>, as identifier followed by
an optional <tt>Frame</tt> or conjunction of <tt>Frame</tt>s as metadata.
</p><p>An <tt>IRICONST</tt> is <tt>rif:iri</tt> constant,
again permitting the shortcut forms defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
One such specialization is <tt>'"' IRI '"^^' 'rif:iri'</tt> from the <tt>Const</tt> production, where <tt>IRI</tt> is a sequence of Unicode characters that forms an internationalized resource identifier as defined by [<a href="#ref-rfc-3987" title="">RFC-3987</a>].
</p><p><br>
</p><p><span id="ex-rif-bld-annotatedgroup-pres-syntax" class="anchor">
<b>Example 5</b> (A RIF-BLD document containing an annotated group).
</span>
</p><p>This example shows a complete document containing a group
formula that consists of two RIF-BLD rules. The first of these rules is
copied from Example 4a. The group is annotated with an IRI identifier
and metadata represented using Dublin Core vocabulary.
</p>
<pre>Document(
  Prefix(ppl  &lt;http://example.com/people#&gt;)
  Prefix(cpt  &lt;http://example.com/concepts#&gt;)
  Prefix(dc   &lt;http://purl.org/dc/terms/&gt;)
  Prefix(func &lt;http://www.w3.org/2007/rif-builtin-function#&gt;)
  Prefix(pred &lt;http://www.w3.org/2007/rif-builtin-predicate#&gt;)
  Prefix(xs   &lt;http://www.w3.org/2001/XMLSchema#&gt;)
  
  (* "http://sample.org"^^rif:iri _pd[dc:publisher -&gt; "http://www.w3.org/"^^rif:iri
                                      dc:date -&gt; "2008-04-04"^^xs:date] *)
  Group
  (
    Forall&nbsp;?item&nbsp;?deliverydate&nbsp;?scheduledate&nbsp;?diffduration&nbsp;?diffdays (
        cpt:reject(ppl:John&nbsp;?item)&nbsp;:-
            And(cpt:perishable(?item)
                cpt:delivered(?item&nbsp;?deliverydate ppl:John)
                cpt:scheduled(?item&nbsp;?scheduledate)
               &nbsp;?diffduration = External(func:subtract-dateTimes(?deliverydate&nbsp;?scheduledate))
               &nbsp;?diffdays = External(func:days-from-duration(?diffduration))
                External(pred:numeric-greater-than(?diffdays 10)))
    )
 
    Forall&nbsp;?item (
        cpt:reject(ppl:Fred&nbsp;?item)&nbsp;:- cpt:unsolicited(?item)
    )
  )
)
</pre>
<p><br>
</p><p><br>
<span id="sec-bld-direct-semantics" class="anchor"></span>
</p>
<a name="Direct_Specification_of_RIF-BLD_Semantics"></a><h2> <span class="mw-headline">3  Direct Specification of RIF-BLD Semantics </span></h2>
<p>This normative section specifies the semantics of RIF-BLD directly, without
relying on [<a href="#ref-rif-fld" title="">RIF-FLD</a>].
</p><p>Recall that the presentation syntax of RIF-BLD allows shorthand notation,
which is specified via the <tt>Prefix</tt>  and <tt>Base</tt> directives, and various shortcuts for integers, strings, and <tt>rif:local</tt> symbols.
The semantics, below, is described using the full syntax, i.e., we
assume that all shortcuts have already been expanded as defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], Section <a href="http://www.w3.org/2005/rules/wiki/DTB#sec-constants" title="DTB">Constants, Symbol Spaces, and Datatypes</a>.
</p><p><span id="sec-truth-values" class="anchor"></span> 
</p>
<a name="Truth_Values"></a><h4> <span class="mw-headline">3.1  Truth Values </span></h4>
<p>The set <i><b>TV</b></i> of truth values in RIF-BLD consists of two values, <b>t</b> and <b>f</b>.
</p><p><span id="sec-model-theory" class="anchor"></span>
</p>
<a name="Semantic_Structures"></a><h4> <span class="mw-headline">3.2  Semantic Structures </span></h4>
<p>The key concept in a model-theoretic semantics of a logic language is the notion of a <i>semantic structure</i> [<a href="#ref-enderton01" title="">Enderton01</a>, <a href="#ref-mendelson97" title="">Mendelson97</a>].
The definition is slightly more general than what is strictly necessary
for RIF-BLD alone. This lays the groundwork for extensions to RIF-BLD
and makes the connection with the <a href="http://www.w3.org/2005/rules/wiki/FLD#sec-fld-semantic-framework" title="FLD">semantics of the RIF framework for logic-based dialects</a> [<a href="#ref-rif-fld" title="">RIF-FLD</a>] more obvious.
</p><p><span id="def-bld-sem-struct" class="anchor"></span> 
<b>Definition (Semantic structure)</b>.
A <i><b>semantic structure</b></i>, <i><b>I</b></i>, is a tuple of the form
&lt;<i><b>TV</b></i>, <i><b>DTS</b></i>, <i><b>D</b></i>, <i><b>D</b></i><sub>ind</sub>,
<i><b>D</b></i><sub>func</sub>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i><sub>V</sub>,
<i><b>I</b></i><sub>F</sub>, <i><b>I</b></i><sub>NF</sub>, <i><b>I</b></i><sub>list</sub>, <i><b>I</b></i><sub>tail</sub>, <i><b>I</b></i><sub>frame</sub>,
<i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>, <i><b>I</b></i><sub>=</sub>,
<i><b>I</b></i><sub>external</sub>, <i><b>I</b></i><sub>truth</sub>&gt;. Here <i><b>D</b></i> is a non-empty set of elements called the <i><b>domain</b></i> of <i><b>I</b></i>, and <i><b>D</b></i><sub>ind</sub>, <i><b>D</b></i><sub>func</sub> are nonempty subsets of <i><b>D</b></i>. <i><b>D</b></i><sub>ind</sub> is used to interpret the elements of <tt>Const</tt> that <a href="#def-bld-context" title="">occur as</a> individuals and <i><b>D</b></i><sub>func</sub> is used to interpret the elements of <tt>Const</tt> that <a href="#def-bld-context" title="">occur in the context of</a> function symbols. As before, <tt>Const</tt> denotes the set of all constant symbols and <tt>Var</tt> the set of all variable symbols. <i><b>DTS</b></i> denotes a set of identifiers for datatypes (please refer to Section <a href="http://www.w3.org/2005/rules/wiki/DTB#sec-data-types" title="DTB">Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] for the semantics of datatypes). 
</p><p>The other components of <i><b>I</b></i> are <i>total</i> mappings defined as follows: 
</p>
<ol>
  <li>
    <i><b>I</b></i><sub>C</sub> maps <tt>Const</tt> to <i><b>D</b></i>.
    <p>
      This mapping interprets constant symbols. In addition:
    </p>
    <ul>
      <li>
	If a constant, <tt>c</tt>&nbsp;∈&nbsp;<tt>Const</tt>,
	is an <i>individual</i> then it is required that
	<i><b>I</b></i><sub>C</sub>(<tt>c</tt>)&nbsp;∈&nbsp;<i><b>D</b></i><sub>ind</sub>.
      </li>
      <li>
	If <tt>c</tt>&nbsp;∈&nbsp;<tt>Const</tt>, is a <i>function symbol</i> (positional or with named arguments) then it is required that <i><b>I</b></i><sub>C</sub>(<tt>c</tt>)&nbsp;∈&nbsp;<i><b>D</b></i><sub>func</sub>.
      </li>
    </ul>
  </li>
  <li>
    <i><b>I</b></i><sub>V</sub> maps <tt>Var</tt> to <i><b>D</b></i><sub>ind</sub>.
    <p>This mapping interprets variable symbols.</p>
  </li>
  <li>
    <i><b>I</b></i><sub>F</sub> maps <i><b>D</b></i> to functions <i><b>D*</b></i><sub>ind</sub> → <i><b>D</b></i> (here <i><b>D*</b></i><sub>ind</sub> is a set of all finite sequences over the domain <i><b>D</b></i><sub>ind</sub>).
    <p>This mapping interprets positional terms. In addition: </p>
    <ul>
      <li>If <tt>d</tt> ∈ <i><b>D</b></i><sub>func</sub> then <i><b>I</b></i><sub>F</sub>(<tt>d</tt>) must be a function <i><b>D*</b></i><sub>ind</sub> → <i><b>D</b></i><sub>ind</sub>.
      </li>
      <li>This
means that when a function symbol is applied to arguments that are
individual objects then the result is also an individual object. </li>
    </ul>
  </li>
  <li><i><b>I</b></i><sub>NF</sub> maps <i><b>D</b></i> to the set of total functions of the form <tt>SetOfFiniteSets</tt>(<tt>ArgNames</tt> × <i><b>D</b></i><sub>ind</sub>) → <i><b>D</b></i>.
    <p>This mapping interprets function symbols with named arguments. In addition:</p>
    <ul>
      <li>If <tt>d</tt> ∈ <i><b>D</b></i><sub>func</sub> then <i><b>I</b></i><sub>NF</sub>(<tt>d</tt>) must be a function <tt>SetOfFiniteSets</tt>(<tt>ArgNames</tt> × <i><b>D</b></i><sub>ind</sub>) → <i><b>D</b></i><sub>ind</sub>.
      </li>
      <li>This is analogous to the interpretation of positional terms with two differences:
        <ul>
          <li>Each pair &lt;<tt>s,v</tt>&gt; ∈ <tt>ArgNames</tt> × <i><b>D</b></i><sub>ind</sub> represents an argument/value pair instead of just a value in the case of a positional term. </li>
          <li>The
arguments of a term with named arguments constitute a finite set of
argument/value pairs rather than a finite ordered sequence of simple
elements. So, the order of the arguments does not matter.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>  
     <i><b>I</b></i><sub>list</sub> and <i><b>I</b></i><sub>tail</sub> are used to interpret lists. They are mappings of the following form:
     <ul>     
       <li>
	 <i><b>I</b></i><sub>list</sub>&nbsp;: <i><b>D</b></i><sub>ind</sub><sup>*</sup> → <i><b>D</b></i><sub>ind</sub> 
       </li>
       <li>
	 <i><b>I</b></i><sub>tail</sub>&nbsp;: <i><b>D</b></i><sub>ind</sub><sup>+</sup>× <i><b>D</b></i><sub>ind</sub> → <i><b>D</b></i><sub>ind</sub> 
       </li>
     </ul>
     <p>
        In addition, these mappings are required to satisfy the following conditions:
     </p>
     <ul>     
       <li>
	The function <i><b>I</b></i><sub>list</sub> is injective (one-to-one).
       </li>
       <li>
	 The set <i><b>I</b></i><sub>list</sub>(<i><b>D</b></i><sub>ind</sub>), henceforth denoted <span id="def-Dlist" class="anchor"><i><b>D</b></i><sub>list</sub></span>, is disjoint from the value spaces of all data types in <i><b>DTS</b></i>.
       </li>
       <li>
	 <i><b>I</b></i><sub>tail</sub>(<tt>a</tt><sub>1</sub>, ..., <tt>a</tt><sub>k</sub>, <i><b>I</b></i><sub>list</sub>(<tt>a</tt><sub>k+1</sub>, ..., <tt>a</tt><sub>k+m</sub>)) = <i><b>I</b></i><sub>list</sub>(<tt>a</tt><sub>1</sub>, ..., <tt>a</tt><sub>k</sub>, <tt>a</tt><sub>k+1</sub>, ..., <tt>a</tt><sub>k+m</sub>). 
       </li>
     </ul>
     <p>
       Note that the last condition above restricts <i><b>I</b></i><sub>tail</sub> only when its last argument is in <i><b>D</b></i><sub>list</sub>. If the last argument of <i><b>I</b></i><sub>tail</sub> is not in <i><b>D</b></i><sub>list</sub>, then the list is a general open one and there are no restrictions on the value of <i><b>I</b></i><sub>tail</sub> except that it must be in <i><b>D</b></i><sub>ind</sub>.
     </p>
  </li>
  <li><i><b>I</b></i><sub>frame</sub> maps <i><b>D</b></i><sub>ind</sub> to total functions of the form <tt>SetOfFiniteBags</tt>(<i><b>D</b></i><sub>ind</sub> × <i><b>D</b></i><sub>ind</sub>) → <i><b>D</b></i>.
    <p>This mapping interprets frame terms. An argument, <tt>d</tt> ∈ <i><b>D</b></i><sub>ind</sub>, to <i><b>I</b></i><sub>frame</sub> represents an object and the finite bag {&lt;<tt>a1,v1</tt>&gt;, ..., &lt;<tt>ak,vk</tt>&gt;} represents a bag of attribute-value pairs for <tt>d</tt>. We will see shortly how <i><b>I</b></i><sub>frame</sub> is used to determine the truth valuation of frame terms. </p>
    <p>Bags
(multi-sets) are used here because the order of the attribute/value
pairs in a frame is immaterial and pairs may repeat. Such repetitions
arise naturally when variables are instantiated with constants. For
instance, <tt>o[?A-&gt;?B&nbsp;?C-&gt;?D]</tt> becomes <tt>o[a-&gt;b&nbsp;a-&gt;b]</tt> if variables <tt>?A</tt> and <tt>?C</tt> are instantiated with the symbol <tt>a</tt> while <tt>?B</tt> and <tt>?D</tt> are instantiated with <tt>b</tt>. (We shall see later that <tt>o[a-&gt;b&nbsp;a-&gt;b]</tt> is equivalent to <tt>o[a-&gt;b]</tt>.)
    </p>
  </li>
  <li><i><b>I</b></i><sub>sub</sub> gives meaning to the subclass relationship. It is a mapping of the form <i><b>D</b></i><sub>ind</sub> × <i><b>D</b></i><sub>ind</sub> → <i><b>D</b></i>.
    <p>
    <i><b>I</b></i><sub>sub</sub> will be further restricted in Section <a href="#sec-interpretation-of-formulas" title="">Interpretation of Formulas</a> to ensure that
    the operator <tt>##</tt> is transitive, i.e., that <tt>c1&nbsp;##&nbsp;c2</tt> and <tt>c2&nbsp;##&nbsp;c3</tt> imply <tt>c1&nbsp;##&nbsp;c3</tt>.
    </p>
  </li>
  <li><i><b>I</b></i><sub>isa</sub> gives meaning to class membership. It is a mapping of the form <i><b>D</b></i><sub>ind</sub> × <i><b>D</b></i><sub>ind</sub> → <i><b>D</b></i>.
    <p>
    <i><b>I</b></i><sub>isa</sub> will be further restricted in Section <a href="#sec-interpretation-of-formulas" title="">Interpretation of Formulas</a> to ensure that
    the relationships <tt>#</tt> and <tt>##</tt> have the usual property that all members of a subclass are also members of the superclass, i.e., that <tt>o&nbsp;#&nbsp;cl</tt> and <tt>cl&nbsp;##&nbsp;scl</tt> imply <tt>o&nbsp;#&nbsp;scl</tt>.
    </p>
  </li>
  <li><i><b>I</b></i><sub>=</sub> is a mapping of the form <i><b>D</b></i><sub>ind</sub> × <i><b>D</b></i><sub>ind</sub> → <i><b>D</b></i>.
    <p>It gives meaning to the equality operator.</p>
  </li>
  <li>
    <i><b>I</b></i><sub>truth</sub> is a mapping of the form <i><b>D</b></i> → <i><b>TV</b></i>.
     <p>It is used to define truth valuation for formulas.</p>
  </li>
  <li>
    <i><b>I</b></i><sub>external</sub> is a mapping from the coherent set of schemas for externally defined functions to total functions <i><b>D</b></i>* → <i><b>D</b></i>. For each external schema <tt>σ = (?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>;&nbsp;τ)</tt> in the <a href="http://www.w3.org/2005/rules/wiki/DTB#def-external-schema-set" title="DTB">coherent set of external schemas</a> associated with the <a href="#def-bld-lang" title="">language</a>, <i><b>I</b></i><sub>external</sub>(<tt>σ</tt>) is a function of the form <i><b>D</b></i><sup>n</sup> → <i><b>D</b></i>.
    <p>
      For every external schema, <tt>σ</tt>,  associated with the language, <i><b>I</b></i><sub>external</sub>(<tt>σ</tt>) is assumed to be specified externally in some document (hence the name <i>external schema</i>). In particular, if <tt>σ</tt> is a schema of a RIF built-in predicate or function, <i><b>I</b></i><sub>external</sub>(<tt>σ</tt>) is specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] so that:
    </p>
      <ul>
        <li>
          If <tt>σ</tt> is a schema of a built-in function then <i><b>I</b></i><sub>external</sub>(<tt>σ</tt>) must be the function defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
        </li>
        <li>
          If <tt>σ</tt> is a schema of a built-in predicate then 
          <i><b>I</b></i><sub>truth</sub><tt> ο </tt>(<i><b>I</b></i><sub>external</sub>(<tt>σ</tt>)) (the composition of <i><b>I</b></i><sub>truth</sub> and <i><b>I</b></i><sub>external</sub>(<tt>σ</tt>), a truth-valued function) must be as specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
        </li>
      </ul>
  </li>
</ol>
<p>
  We also define the following mapping from terms to <i><b>D</b></i>, which we denote using the same symbol <i><b>I</b></i> as the one used for semantic structures. This overloading is convenient and creates no ambiguity.
</p>
<ul>
  <li>
    <i><b>I</b></i>(<tt>k</tt>) = <i><b>I</b></i><sub>C</sub>(<tt>k</tt>), if <tt>k</tt> is a symbol in <tt>Const</tt>
  </li>
  <li>
    <i><b>I</b></i>(<tt>?v</tt>) = <i><b>I</b></i><sub>V</sub>(<tt>?v</tt>), if <tt>?v</tt> is a variable in <tt>Var</tt>
  </li>
  <li>
    <i><b>I</b></i>(<tt>f(t<sub>1</sub> ... t<sub>n</sub>)</tt>) = <i><b>I</b></i><sub>F</sub>(<i><b>I</b></i>(<tt>f</tt>))(<i><b>I</b></i>(<tt>t<sub>1</sub></tt>),...,<i><b>I</b></i>(<tt>t<sub>n</sub></tt>))
  </li>
  <li>
    <i><b>I</b></i>(<tt>f(s<sub>1</sub>-&gt;v<sub>1</sub> ... s<sub>n</sub>-&gt;v<sub>n</sub>)</tt>) = <i><b>I</b></i><sub>NF</sub>(<i><b>I</b></i>(<tt>f</tt>))({&lt;<tt>s<sub>1</sub></tt>,<i><b>I</b></i>(<tt>v<sub>1</sub></tt>)&gt;,...,&lt;<tt>s<sub>n</sub></tt>,<i><b>I</b></i>(<tt>v<sub>n</sub></tt>)&gt;})
  <p>
    Here we use {...} to denote a set of argument/value pairs. 
  </p>
  </li>
  <li>  
     For list terms, the mapping is defined as follows:
     <ul>     
       <li>
	 <i><b>I</b></i>(<tt>List()</tt>) = <i><b>I</b></i><sub>list</sub>(<tt>&lt;&gt;</tt>). 
	 <p>
	   Here <tt>&lt;&gt;</tt> denotes an empty list of elements of <i><b>D</b></i><sub>ind</sub>. (Note that the domain of <i><b>I</b></i><sub>list</sub> is <i><b>D</b></i><sub>ind</sub><sup>*</sup>, so <i><b>D</b></i><sub>ind</sub><sup>0</sup> is an empty list of elements of <i><b>D</b></i><sub>ind</sub>.)
	 </p>
       </li>
       <li>
	 <i><b>I</b></i>(<tt>List(t</tt><sub>1</sub> ... <tt>t</tt><sub>n</sub>)) = <i><b>I</b></i><sub>list</sub>(<i><b>I</b></i>(<tt>t</tt><sub>1</sub>), ..., <i><b>I</b></i>(<tt>t</tt><sub>n</sub>)), if <tt>n&gt;0</tt>. 
       </li>
       <li>
	 <i><b>I</b></i>(<tt>List(t</tt><sub>1</sub> ... <tt>t</tt><sub>n</sub> | <tt>t</tt>)) = <i><b>I</b></i><sub>tail</sub>(<i><b>I</b></i>(<tt>t</tt><sub>1</sub>), ..., <i><b>I</b></i>(<tt>t</tt><sub>n</sub>), <i><b>I</b></i>(<tt>t</tt>)), if <tt>n&gt;0</tt>. 
       </li>
     </ul>
  </li>
  <li>
    <i><b>I</b></i>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = <i><b>I</b></i><sub>frame</sub>(<i><b>I</b></i>(<tt>o</tt>))({&lt;<i><b>I</b></i>(<tt>a<sub>1</sub></tt>),<i><b>I</b></i>(<tt>v<sub>1</sub></tt>)&gt;, ..., &lt;<i><b>I</b></i>(<tt>a<sub>n</sub></tt>),<i><b>I</b></i>(<tt>v<sub>n</sub></tt>)&gt;})
  <p>
Here {...} denotes a bag of attribute/value pairs. Jumping ahead, we
note that duplicate elements in such a bag do not affect the value of <i><b>I</b></i><sub>frame</sub>(<i><b>I</b></i>(<tt>o</tt>)) -- see Section <a href="#sec-interpretation-of-formulas" title="">Interpretation of Non-document Formulas</a>. For instance, <i><b>I</b></i>(<tt>o[a-&gt;b a-&gt;b]</tt>) = <i><b>I</b></i>(<tt>o[a-&gt;b]</tt>).
  </p>
  </li>
  <li>
    <i><b>I</b></i>(<tt>c1##c2</tt>) = <i><b>I</b></i><sub>sub</sub>(<i><b>I</b></i>(<tt>c1</tt>), <i><b>I</b></i>(<tt>c2</tt>))
  </li>
  <li>
    <i><b>I</b></i>(<tt>o#c</tt>) = <i><b>I</b></i><sub>isa</sub>(<i><b>I</b></i>(<tt>o</tt>), <i><b>I</b></i>(<tt>c</tt>))
  </li>
  <li>
    <i><b>I</b></i>(<tt>x=y</tt>) = <i><b>I</b></i><sub>=</sub>(<i><b>I</b></i>(x), <i><b>I</b></i>(y))
  </li>
  <li>
    <i><b>I</b></i>(<tt>External(t)</tt>) = <i><b>I</b></i><sub>external</sub>(<tt>σ</tt>)(<i><b>I</b></i>(<tt>s<sub>1</sub></tt>), ..., <i><b>I</b></i>(<tt>s<sub>n</sub></tt>)), if <tt>t</tt> is an instance of the external schema <tt>σ = (?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>;&nbsp;τ)</tt> by substitution <tt>?X<sub>1</sub>/s<sub>1</sub> ...&nbsp;?X<sub>n</sub>/s<sub>1</sub></tt>.
    <p>
      Note that, by definition, <tt>External(t)</tt> is well-formed only if <tt>t</tt> is an instance of an external schema. Furthermore, by the <a href="http://www.w3.org/2005/rules/wiki/DTB#def-external-schema-set" title="DTB">definition of coherent sets of external schemas</a>, <tt>t</tt> can be an instance of at most one such schema, so <i><b>I</b></i>(<tt>External(t)</tt>) is well-defined.
    </p>
  </li>
</ul>
<p><i><b>The effect of datatypes.</b></i> The set <i><b>DTS</b></i> must include the datatypes described in Section <a href="http://www.w3.org/2005/rules/wiki/DTB#sec-data-types" title="DTB">Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p><p><br>
The datatype identifiers in <i><b>DTS</b></i> impose the following restrictions. Given <tt>dt</tt> ∈ <i><b>DTS</b></i>, let <i><b>LS</b></i><sub>dt</sub> denote the lexical space of <tt>dt</tt>, <i><b>VS</b></i><sub>dt</sub> denote its value space, and <i><b>L</b></i><sub>dt</sub>: <i><b>LS</b></i><sub>dt</sub> → <i><b>VS</b></i><sub>dt</sub> the lexical-to-value-space mapping (for the definitions of these concepts, see Section <a href="http://www.w3.org/2005/rules/wiki/DTB#sec-data-types" title="DTB">Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]). Then the following must hold: 
</p>
<ul><li> <i><b>VS</b></i><sub>dt</sub> ⊆ <i><b>D</b></i><sub>ind</sub>; and
</li><li> For each constant <tt>"lit"^^dt</tt> such that <tt>lit</tt> ∈ <i><b>LS</b></i><sub>dt</sub>, <i><b>I</b></i><sub>C</sub>(<tt>"lit"^^dt</tt>) = <i><b>L</b></i><sub>dt</sub>(<tt>lit</tt>). 
</li></ul>
<p>That is, <i><b>I</b></i><sub>C</sub> must map the constants of a datatype <tt>dt</tt> in accordance with <i><b>L</b></i><sub>dt</sub>. 
</p><p>RIF-BLD does not impose restrictions on <i><b>I</b></i><sub>C</sub> for constants in symbol spaces that are not datatypes included in <i><b>DTS</b></i>.  &nbsp;&nbsp;☐
</p><p><br>
</p><p><span id="sec-semantics-metadata" class="anchor"></span>
</p>
<a name="RIF-BLD_Annotations_in_the_Semantics"></a><h4> <span class="mw-headline">3.3  RIF-BLD Annotations in the Semantics </span></h4>
<p>RIF-BLD annotations are stripped before the mappings that constitute
RIF-BLD semantic structures are applied. Likewise, they are stripped
before applying the truth valuation, <i>TVal</i><sub>I</sub>, defined in the next section. Thus, identifiers and metadata have no effect on the formal semantics.
</p><p>Note that although identifiers and metadata associated with
RIF-BLD formulas are ignored by the semantics, they can be extracted by
XML tools. The frame terms used to represent RIF-BLD metadata can then
be fed to other RIF-BLD rules, thus enabling reasoning about metadata.
RIF-BLD does not define any particular semantics for metadata, however.
</p><p><br>
</p><p><span id="sec-interpretation-of-formulas" class="anchor"></span>
</p>
<a name="Interpretation_of_Non-document_Formulas"></a><h4> <span class="mw-headline">3.4  Interpretation of Non-document Formulas </span></h4>
<p>This section defines how a semantic structure, <i><b>I</b></i>, determines
the truth value <i>TVal</i><sub>I</sub>(<tt>φ</tt>)  of a RIF-BLD formula, <tt>φ</tt>, where <tt>φ</tt> is any formula other than a document formula. Truth valuation of document formulas is defined in the next section.
</p><p>We define a mapping, <i>TVal</i><sub>I</sub>, from the set of all non-document formulas to <i><b>TV</b></i>. Note that the definition implies that <i>TVal</i><sub>I</sub>(<tt>φ</tt>) is defined <em>only if</em> the set <i><b>DTS</b></i> of the datatypes of <i><b>I</b></i> includes all the datatypes mentioned in <tt>φ</tt> and <i><b>I</b></i><sub>external</sub> is defined on all externally defined functions and predicates in <tt>φ</tt>. 
</p><p><br>
</p><p><span id="def-bld-truth" class="anchor"></span> 
<b>Definition (Truth valuation)</b>.
<i><b>Truth valuation</b></i> for well-formed formulas in RIF-BLD is determined using the following function, denoted <i>TVal</i><sub>I</sub>:
</p>
<ol>
  <li><i>Positional atomic formulas</i>: <i>TVal</i><sub>I</sub>(<tt>r(t<sub>1</sub> ... t<sub>n</sub>)</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>r(t<sub>1</sub> ... t<sub>n</sub>)</tt>)) </li>
  <li><i>Atomic formulas with named arguments</i>: <i>TVal</i><sub>I</sub>(<tt>p(s<sub>1</sub>-&gt;v<sub>1</sub> ... s<sub>k</sub>-&gt;v<sub>k</sub>)</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>p(s<sub>1</sub>-&gt;v<sub>1</sub> ... s<sub>k</sub>-&gt;v<sub>k</sub>)</tt>)). </li>
  <li><i>Equality</i>: <i>TVal</i><sub>I</sub>(<tt>x&nbsp;=&nbsp;y</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>x&nbsp;=&nbsp;y</tt>)).
    <ul>
      <li>To ensure that equality has precisely the expected properties, it is required that:
        <ul>
	  <li>
	    <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>x&nbsp;=&nbsp;y</tt>)) = <b>t</b> if <i><b>I</b></i>(<tt>x</tt>) = <i><b>I</b></i>(<tt>y</tt>) and that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>x&nbsp;=&nbsp;y</tt>)) = <b>f</b> otherwise.
	  </li>
        </ul>
      </li>
      <li>This is tantamount to saying that <i>TVal</i><sub>I</sub>(<tt>x&nbsp;=&nbsp;y</tt>) = <b>t</b> if and only if  <i><b>I</b></i>(x) = <i><b>I</b></i>(y).</li>
    </ul>
  </li>
  <li><i>Subclass</i>: <i>TVal</i><sub>I</sub>(<tt>sc&nbsp;##&nbsp;cl</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>sc&nbsp;##&nbsp;cl</tt>)).
    <p>To ensure that the operator <tt>##</tt> is transitive, i.e., <tt>c1&nbsp;##&nbsp;c2</tt> and <tt>c2&nbsp;##&nbsp;c3</tt> imply <tt>c1&nbsp;##&nbsp;c3</tt>, the following is required:
    </p>
      <ul>
	<li>
          For all <tt>c1</tt>, <tt>c2</tt>, <tt>c3</tt> ∈ <i><b>D</b></i>, &nbsp; if <i>TVal</i><sub>I</sub>(<tt>c1&nbsp;##&nbsp;c2</tt>) = <i>TVal</i><sub>I</sub>(<tt>c2&nbsp;##&nbsp;c3</tt>) = <b>t</b> &nbsp; then <i>TVal</i><sub>I</sub>(<tt>c1&nbsp;##&nbsp;c3</tt>) = <b>t</b>.
	</li>
      </ul>
  </li>
  <li><i>Membership</i>: <i>TVal</i><sub>I</sub>(<tt>o&nbsp;#&nbsp;cl</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>o&nbsp;#&nbsp;cl</tt>)).
    <p>To ensure that all members of a subclass are also members of the superclass, i.e., <tt>o&nbsp;#&nbsp;cl</tt> and <tt>cl&nbsp;##&nbsp;scl</tt> imply <tt>o&nbsp;#&nbsp;scl</tt>, the following is required:
    </p>
      <ul>
	<li>
        For all <tt>o</tt>, <tt>cl</tt>, <tt>scl</tt> ∈ <i><b>D</b></i>, &nbsp; if <i>TVal</i><sub>I</sub>(<tt>o&nbsp;#&nbsp;cl</tt>) = <i>TVal</i><sub>I</sub>(<tt>cl&nbsp;##&nbsp;scl</tt>) = <b>t</b> &nbsp; then &nbsp; <i>TVal</i><sub>I</sub>(<tt>o&nbsp;#&nbsp;scl</tt>) = <b>t</b>. 
	</li>
      </ul>
  </li>
  <li><i>Frame</i>: <i>TVal</i><sub>I</sub>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>)).
    <p>
      Since the bag of attribute/value pairs associated with an object <tt>o</tt> represents the conjunction of assertions represented by these pairs, the following is required, if <tt>k &gt; 0</tt>: 
    </p>
      <ul>
	<li>
        <i>TVal</i><sub>I</sub>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = <b>t</b> if and only if  <i>TVal</i><sub>I</sub>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub>]</tt>) = ... = <i>TVal</i><sub>I</sub>(<tt>o[a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = <b>t</b>. 
	</li>
      </ul>
  </li>
  <li>
    <i>Externally defined atomic formula</i>: <i>TVal</i><sub>I</sub>(<tt>External(t)</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>external</sub>(<tt>σ</tt>)(<i><b>I</b></i>(<tt>s<sub>1</sub></tt>), ..., <i><b>I</b></i>(<tt>s<sub>n</sub></tt>))), if <tt>t</tt> is an atomic formula that is an instance of the external schema <tt>σ = (?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>; τ)</tt> by substitution <tt>?X<sub>1</sub>/s<sub>1</sub> ...&nbsp;?X<sub>n</sub>/s<sub>1</sub></tt>.
    <p>
      Note that, by definition, <tt>External(t)</tt> is well-formed only if <tt>t</tt> is an instance of an external schema. Furthermore, by the <a href="http://www.w3.org/2005/rules/wiki/DTB#def-external-schema-set" title="DTB">definition of coherent sets of external schemas</a>, <tt>t</tt> can be an instance of at most one such schema, so <i><b>I</b></i>(<tt>External(t)</tt>) is well-defined.
    </p>
  </li>
  <li><i>Conjunction</i>: <i>TVal</i><sub>I</sub>(<tt>And(</tt>c<sub>1</sub> ... c<sub>n</sub><tt>)</tt>) = <b>t</b> if and only if <i>TVal</i><sub>I</sub>(c<sub>1</sub>) = ... = <i>TVal</i><sub>I</sub>(c<sub>n</sub>) = <b>t</b>. Otherwise, <i>TVal</i><sub>I</sub>(<tt>And(</tt>c<sub>1</sub> ... c<sub>n</sub><tt>)</tt>) = <b>f</b>.
  <p>
  The empty conjunction is treated as a tautology, so <i>TVal</i><sub>I</sub>(<tt>And()</tt>) = <b>t</b>.
  </p>
  </li>
  <li><i>Disjunction</i>: <i>TVal</i><sub>I</sub>(<tt>Or(</tt>c<sub>1</sub> ... c<sub>n</sub><tt>)</tt>) = <b>f</b> if and only if  <i>TVal</i><sub>I</sub>(c<sub>1</sub>) = ... = <i>TVal</i><sub>I</sub>(c<sub>n</sub>) = <b>f</b>. Otherwise, <i>TVal</i><sub>I</sub>(<tt>Or(</tt>c<sub>1</sub> ... c<sub>n</sub><tt>)</tt>) = <b>t</b>.
  <p>
  The empty disjunction is treated as a contradiction, so <i>TVal</i><sub>I</sub>(<tt>Or()</tt>) = <b>f</b>.
  </p>
  </li>
  <li><i>Quantification</i>:
    <ul>
      <li><i>TVal</i><sub>I</sub>(<tt>Exists&nbsp;?v<sub>1</sub> ...&nbsp;?v<sub>n</sub> (φ)</tt>) = <b>t</b> if and only if for some <i><b>I</b></i>*, described below,  <i>TVal</i><sub>I*</sub>(<tt>φ</tt>) = <b>t</b>.</li>
      <li><i>TVal</i><sub>I</sub>(<tt>Forall&nbsp;?v<sub>1</sub> ...&nbsp;?v<sub>n</sub> (φ))</tt> = <b>t</b> if and only if for every <i><b>I</b></i>*, described below,  <i>TVal</i><sub>I*</sub>(<tt>φ</tt>) = <b>t</b>.</li>
    </ul>
    <p>
      Here <i><b>I</b></i>* is a semantic structure of the form &lt;<i><b>TV</b></i>, <i><b>DTS</b></i>, <i><b>D</b></i>, <i><b>D</b></i><sub>ind</sub>, <i><b>D</b></i><sub>func</sub>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i>*<sub>V</sub>, <i><b>I</b></i><sub>F</sub>, <i><b>I</b></i><sub>NF</sub>, <i><b>I</b></i><sub>list</sub>, <i><b>I</b></i><sub>tail</sub>, <i><b>I</b></i><sub>frame</sub>, <i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>, <i><b>I</b></i><sub>=</sub>, <i><b>I</b></i><sub>external</sub>, <i><b>I</b></i><sub>truth</sub>&gt;, which is exactly like <i><b>I</b></i>, except that the mapping <i><b>I</b></i>*<sub>V</sub>, is used instead of <i><b>I</b></i><sub>V</sub>. &nbsp; <i><b>I</b></i>*<sub>V</sub> is defined to coincide with <i><b>I</b></i><sub>V</sub> on all variables except, possibly, on <tt>?v<sub>1</sub></tt>,...,<tt>?v<sub>n</sub></tt>.
    </p>
  </li>
  <li><i>Rule implication</i>:
    <ul>
      <li>
        <i>TVal</i><sub>I</sub>(<i>conclusion</i>&nbsp;:- <i>condition</i>) = <b>t</b>, if either <i>TVal</i><sub>I</sub>(<i>conclusion</i>)=<b>t</b> or  <i>TVal</i><sub>I</sub>(<i>condition</i>)=<b>f</b>.
      </li>
      <li>
        <i>TVal</i><sub>I</sub>(<i>conclusion</i>&nbsp;:- <i>condition</i>) = <b>f</b> &nbsp; otherwise.
      </li>
    </ul>
  </li>
  <li><i>Groups of rules</i>:
    <p>
       If <tt>Γ</tt> is a group formula of the form  <tt>Group(φ<sub>1</sub> ... φ<sub>n</sub>)</tt> then
    </p>
    <ul>       
      <li>
       <i>TVal</i><sub>I</sub>(<tt>Γ</tt>) = <b>t</b> if and only if <i>TVal</i><sub>I</sub>(<tt>φ<sub>1</sub></tt>) = <b>t</b>, ..., <i>TVal</i><sub>I</sub>(<tt>φ<sub>n</sub></tt>) = <b>t</b>.
      </li>
      <li>
          <i>TVal</i><sub>I</sub>(<tt>Γ</tt>) = <b>f</b> &nbsp; otherwise.
      </li>
    </ul>
    <p>
This means that a group of rules is treated as a conjunction. In
particular, the empty group is treated as a tautology, so <i>TVal</i><sub>I</sub>(<tt>Group()</tt>) = <b>t</b>.&nbsp;&nbsp;☐
    </p>
  </li>
</ol>
<p><br>
</p><p><span id="sec-interpretation-of-documents" class="anchor"></span>
</p>
<a name="Interpretation_of_Documents"></a><h4> <span class="mw-headline">3.5  Interpretation of Documents </span></h4>
<p>Document formulas are interpreted using <i>semantic multi-structures</i>, which
are sets of closely related semantics structures. The need for multi-structures
arises due to the fact that a RIF-BLD document can import other documents and
thus is essentially a multi-document object.  One interesting aspect of the
multi-document semantics is that <tt>rif:local</tt> symbols that belong to
different documents can have different meanings.
</p><p><span id="def-bld-semantic-multistruct" class="anchor"></span> 
<b>Definition (Semantic multi-structure).</b>
A <i><b>semantic multi-structure</b></i> <b>Î</b> is a set of semantic structures of the form {<i><b>J</b></i>,<i><b>I</b></i>; <i><b>I</b></i><sup><tt>i<sub>1</sub></tt></sup>, <i><b>I</b></i><sup><tt>i<sub>2</sub></tt></sup>, ...}, where
</p>
<ul>
  <li>
     <i><b>I</b></i> and <i><b>J</b></i> are <a href="#def-bld-sem-struct" title="">RIF-BLD semantic structures</a>; and
  </li>
  <li>  
    <i><b>I</b></i><sup><tt>i<sub>1</sub></tt></sup>, <i><b>I</b></i><sup><tt>i<sub>2</sub></tt></sup>, etc., are semantic structures <i><b>adorned</b></i> with the <a href="#ref-locator" title="">locators</a> of <i>distinct</i> RIF-BLD formulas (one can think of these adorned structures as locator-structure pairs).
  </li>
</ul>
<p>All the structures in <b>Î</b> (adorned and non-adorned) are identical in all respects except for the following:
</p>
<ul>       
  <li>
   The mappings <i><b>J</b></i><sub>C</sub>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i><sub>C</sub><sup><tt>i<sub>1</sub></tt></sup>, <i><b>I</b></i><sub>C</sub><sup><tt>i<sub>2</sub></tt></sup>, ... may differ on the constants in <tt>Const</tt> that belong to the <tt><a href="http://www.w3.org/2005/rules/wiki/DTB#rif-local-space" title="DTB">rif:local</a></tt> symbol space.
&nbsp; &nbsp; &nbsp; &nbsp; ☐ 
  </li>
</ul>
<p>As will be seen from the next definition, the structure <i><b>I</b></i> in the above is used to interpret document formulas, and the adorned structures of the form <i><b>I</b></i><sup><tt>i<sub>k</sub></tt></sup> are used to interpret imported documents. The structure <i><b>J</b></i> is used in the definition of entailment to interpret non-document formulas.
</p><p>The semantics of RIF documents is now defined as follows.
</p><p><b>Definition (Truth valuation of document formulas).</b>
Let <tt>Δ</tt> be a document formula and let 
<tt>Δ</tt><sub>1</sub>, ..., <tt>Δ</tt><sub>n</sub> be all the RIF-BLD document formulas that are <i>imported</i> (directly or indirectly, according to Definition <a href="#def-bld-imported-doc" title="">Imported document</a>) into <tt>Δ</tt>.
Let <tt>Γ</tt>, <tt>Γ<sub>1</sub></tt>, ..., <tt>Γ<sub>n</sub></tt> denote the respective group formulas <a href="#def-associated-group" title="">associated</a> with these documents.
Let <b>Î</b> = {<i><b>J</b></i>,<i><b>I</b></i>; <i><b>I</b></i><sup><tt>i<sub>1</sub></tt></sup>, ..., <i><b>I</b></i><sup><tt>i<sub>n</sub></tt></sup>, ...} be a semantic multi-structure that contains the semantic structures adorned with the locators <tt>i<sub>1</sub></tt>, ..., <tt>i<sub>n</sub></tt> of the documents <tt>Δ</tt><sub>1</sub>, ..., <tt>Δ</tt><sub>n</sub>.
Then we define:
</p>
<ul>       
  <li>
   <i>TVal</i><sub>Î</sub>(<tt>Δ</tt>) =  <b>t</b>  if and only if  <i>TVal</i><sub>I</sub>(<tt>Γ</tt>) =  <i>TVal</i><sub>I<sup><tt>i<sub>1</sub></tt></sup></sub>(<tt>Γ<sub>1</sub></tt>) =  ... = <i>TVal</i><sub>I<sup><tt>i<sub>k</sub></tt></sup></sub>(<tt>Γ<sub>n</sub></tt>) = <b>t</b>.
&nbsp; &nbsp; &nbsp; &nbsp; ☐  
  </li>
</ul>
<p>Note that this definition considers only those document formulas
that are reachable via the one-argument import directives. Two argument
import directives are not covered here. Their semantics is defined by
the document RIF RDF and OWL Compatibility [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>].
</p><p>Also note that some of the <tt>Γ<sub>i</sub></tt> above may be missing since all parts in a document formula are optional. In this case, we assume that <tt>Γ<sub>i</sub></tt> is a tautology, such as <tt>And()</tt>, and every  <i>TVal</i> function maps such a <tt>Γ<sub>i</sub></tt> to the truth value <b>t</b>.
</p><p>For non-document formulas, we extend <i>TVal</i><sub>Î</sub>(<tt>φ</tt>) from regular semantic structures to multi-structures as follows. Let <b>Î</b> = {<i><b>J</b></i>, <i><b>I</b></i>; ...} be a semantic multi-structure. Then <i>TVal</i><sub>Î</sub>(<tt>φ</tt>) = <i>TVal</i><sub>J</sub>(<tt>φ</tt>).
</p><p>The above definitions make the intent behind the <tt><a href="http://www.w3.org/2005/rules/wiki/DTB#rif-local-space" title="DTB">rif:local</a></tt>
constants clear: occurrences of such constants in different documents
can be interpreted differently even if they have the same name.
Therefore, each document can choose the names for the <tt>rif:local</tt> constants freely and without regard to the names of such constants used in the imported documents.
</p><p>For the relationship between <tt>rif:local</tt> and RDF blank nodes readers are referred to Section <a href="http://www.w3.org/2005/rules/wiki/SWC#sec-swc-symbols-rdf-owl" title="SWC">Symbols in RIF Versus RDF/OWL (Informative)</a> of [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>].
</p><p><br>
</p><p><span id="sec-logical-entailment" class="anchor"></span>
</p>
<a name="Logical_Entailment"></a><h4> <span class="mw-headline">3.6  Logical Entailment </span></h4>
<p>We now define what it means for a set of RIF-BLD rules (embedded in
a group or a document formula) to entail another RIF-BLD formula. In
RIF-BLD we are mostly interested in entailment of RIF condition
formulas, which can be viewed as queries to RIF-BLD documents.
Entailment of condition formulas provides formal underpinning to
RIF-BLD queries.
</p><p><br>
<span id="def-bld-model-formula" class="anchor"></span> 
<b>Definition (Models).</b>
A multi-structure <b>Î</b> is a <i><b>model</b></i> of a formula, <tt>φ</tt>, written as <b>Î</b><tt>&nbsp;|=&nbsp;φ</tt>, iff <i>TVal</i><sub>Î</sub>(<tt>φ</tt>) = <b>t</b>. Here <tt>φ</tt> can be a document or a non-document formula. &nbsp;&nbsp;☐
</p><p><span id="def-bld-entail" class="anchor"></span> 
<b>Definition (Logical entailment).</b>
Let <tt>φ</tt> and <tt>ψ</tt> be (document or non-document) formulas. We say that <tt>φ</tt> <i><b>entails</b></i> <tt>ψ</tt>,  written as <tt>φ&nbsp;|=&nbsp;ψ</tt>, if and only if for every multi-structure, <b>Î</b>, for which both <i>TVal</i><sub>Î</sub>(<tt>φ</tt>) and <i>TVal</i><sub>Î</sub>(<tt>ψ</tt>) are defined, <b>Î</b><tt>&nbsp;|=&nbsp;φ</tt> implies <b>Î</b><tt>&nbsp;|=&nbsp;ψ</tt>. &nbsp;&nbsp;☐
</p><p><br>Note that one consequence of the multi-document semantics of
RIF-BLD is that local constants specified in one document cannot be
queried from another document. For instance, if one document, <tt>Δ'</tt>, has the fact <tt>"http://example.com/ppp"^^rif:iri("abc"^^rif:local)</tt> while another document formula, <tt>Δ</tt>, imports <tt>Δ'</tt> and has the rule <tt>"http://example.com/qqq"^^rif:iri(?X)&nbsp;:- "http://example.com/ppp"^^rif:iri(?X)</tt>, then <tt>Δ |= "http://example.com/qqq"^^rif:iri("abc"^^rif:local)</tt> does <em>not</em> hold. This is because the symbol <tt>"abc"^^rif:local</tt> in <tt>Δ'</tt> and <tt>Δ</tt> is treated as different constants by semantic multi-structures. 
</p><p>This behavior of local symbols should be contrasted with the behavior of <tt>rif:iri</tt> symbols. Suppose, in the above scenario, <tt>Δ'</tt> also has the fact  <tt>"http://example.com/ppp"^^rif:iri("http://cde.example.org"^^rif:iri)</tt>. Then <tt>Δ |= "http://example.com/qqq"^^rif:iri("http://cde.example.org"^^rif:iri)</tt> <em>does</em> hold.
</p><p><br>
<span id="sec-xml-bld" class="anchor"></span>
</p>
<a name="XML_Serialization_Syntax_for_RIF-BLD"></a><h2> <span class="mw-headline">4  XML Serialization Syntax for RIF-BLD </span></h2>
<p>The RIF-BLD XML serialization defines
</p>
<ul><li> a <i>normative</i> mapping from the RIF-BLD presentation syntax to XML (Section <a href="#sec-translation" title="">Mapping from the Presentation Syntax to the XML Syntax</a>), and
</li><li> a <i>normative</i> XML schema for the XML syntax (Appendix <a href="#sec-xsd-bld" title="">XML Schema for BLD</a>).
</li></ul>
<p>Recall that the syntax of RIF-BLD is not context-free and thus
cannot be fully captured by EBNF or XML Schema. Still, validity with
respect to XML Schema can be a useful test. To reflect this state of
affairs, we define two notions of syntactic correctness. The weaker
notion checks correctness only with respect to XML Schema, while the
stricter notion represents "true" syntactic correctness.
</p><p><span id="def-bld-valid-xml" class="anchor"></span> 
<b>Definition (Valid BLD document in XML syntax).</b>
A <i><b>valid</b></i> BLD document in the XML syntax is an XML document that is valid with respect to the XML schema in Appendix <a href="#sec-xsd-bld" title="">XML Schema for BLD</a>. &nbsp;&nbsp;☐
</p><p><span id="def-bld-admissible-xml" class="anchor"></span> 
<b>Definition (Admissible BLD document in XML syntax).</b>
An <i><b>admissible</b></i>
BLD document in the XML syntax is a valid BLD document in XML syntax
that is the image of a well-formed RIF-BLD document in the presentation
syntax (see Definition <a href="#def-bld-wff" title="">Well-formed formula</a> in Section <a href="#sec-formulas" title="">Formulas</a>) under the presentation-to-XML syntax mapping <tt>χ<sub>bld</sub></tt> defined in Section <a href="#sec-translation" title="">Mapping from the Presentation Syntax to the XML Syntax</a>. &nbsp;&nbsp;☐
</p><p>The XML serialization for RIF-BLD is based on an <i>alternating</i> or <i>striped</i> syntax [<a href="#ref-alternating-normal-form" title="">ANF01</a>]. A striped serialization views XML documents as objects and divides all XML tags into class descriptors, called <i>type tags</i>, and property descriptors, called <i>role tags</i> [<a href="#ref-type-and-role-tags" title="">TRT03</a>]. We follow the tradition of using capitalized names for type tags and lowercase names for role tags.
</p><p>The all-uppercase classes in the presentation syntax, such as <tt>FORMULA</tt>, become XML Schema groups in Appendix <a href="#sec-xsd-bld" title="">XML Schema for BLD</a>. They are not visible in instance markup. The other classes as well as non-terminals and symbols (such as <tt>Exists</tt> or <tt>=</tt>) become XML elements with optional attributes, as shown below.
</p><p>RIF-BLD uses [<a href="#ref-xml-1-point-0" title="">XML1.0</a>] for its XML syntax.
</p><p><br>
<span id="sec-xml-condition-language" class="anchor"></span> 
</p>
<a name="XML_for_the_Condition_Language"></a><h3> <span class="mw-headline">4.1  XML for the Condition Language </span></h3>
<p>XML serialization of RIF-BLD in Section <a href="#sec-ebnf-condition-language" title="">EBNF for RIF-BLD Condition Language</a> uses the following elements.
</p>
<pre>- And       (conjunction)
- Or        (disjunction)
- Exists    (quantified formula for 'Exists', containing declare and formula roles)
- declare   (declare role, containing a Var)
- formula   (formula role, containing a FORMULA)
- Atom      (atom formula, positional or with named arguments)
- External  (external call, containing a content role)
- content   (content role, containing an Atom, for predicates, or Expr, for functions)
- Member    (member formula)
- Subclass  (subclass formula)
- Frame     (Frame formula)
- object    (Member/Frame role, containing a TERM or an object description)
- op        (Atom/Expr role for predicates/functions as operations)
- args      (Atom/Expr positional arguments role, with ordered="yes" attribute, containing n TERMs)
- instance  (Member instance role)
- class     (Member class role)
- sub       (Subclass sub-class role)
- super     (Subclass super-class role)
- slot      (Atom/Expr or Frame slot role, with ordered="yes" attribute, containing a Name or TERM followed by a TERM)
- Equal     (prefix version of term equation '=')
- left      (Equal left-hand side role)
- right     (Equal right-hand side role)
- Expr      (expression formula, positional or with named arguments)
- List      (list term, closed or open)
- rest      (list rest role, corresponding to '|')
- Const     (individual, function, or predicate symbol, with 'type' attribute)
- Name      (name of named argument)
- Var       (logic variable)
   
- id        (identifier role, containing IRICONST)
- meta      (meta role, containing metadata as a Frame or Frame conjunction)
</pre>
<p>The name of a prefix is not associated with an XML element, since it is handled via preprocessing as discussed in Section <a href="#sec-translation-condition-language" title="">Mapping of the Condition Language</a>.
</p><p>The <tt>id</tt> and <tt>meta</tt> elements, which are expansions of the <tt>IRIMETA</tt> element, can occur optionally as the initial children of any Class element.
</p><p>For the XML Schema definition of the RIF-BLD condition language see Appendix <a href="#sec-xsd-bld" title="">XML Schema for BLD</a>. 
</p><p>The XML syntax for symbol spaces uses the <tt>type</tt> attribute associated with the XML element <tt>Const</tt>. For instance, a literal in the <tt>xs:dateTime</tt> datatype is represented as follows:
</p><p><tt>&lt;Const&nbsp;type="&amp;xs;dateTime"&gt;2007-11-23T03:55:44-02:30&lt;/Const&gt;</tt>
</p><p>RIF-BLD also uses the <tt>ordered="yes"</tt> attribute to indicate that the children of 
<tt>args</tt> and <tt>slot</tt> elements are ordered.
</p><p><br>
<span id="ex-RIF-condition-serialization" class="anchor">
<b>Example 6</b> (A RIF condition and its XML serialization).
</span> 
</p><p>This example illustrates XML serialization for RIF conditions.
As before, the compact URI notation is used for better readability.
Assume that the following prefix directives are found in the preamble
to the document, whose XML form will be illustrated in Example 8:
</p>
<pre>Prefix(bks    &lt;http://example.com/books#&gt;)
Prefix(cpt    &lt;http://example.com/concepts#&gt;)
Prefix(curr   &lt;http://example.com/currencies#&gt;)
Prefix(rif    &lt;http://www.w3.org/2007/rif#&gt;)
Prefix(xs     &lt;http://www.w3.org/2001/XMLSchema#&gt;)
</pre>
<p>RIF condition:
</p>
<pre>   And (Exists&nbsp;?Buyer (cpt:purchase(?Buyer&nbsp;?Seller
                                    cpt:book(?Author bks:LeRif)
                                    curr:USD(49)))
       &nbsp;?Seller=?Author )

</pre>
<p>XML serialization:
</p>
<pre>   &lt;And&gt;
     &lt;formula&gt;
       &lt;Exists&gt;
         &lt;declare&gt;&lt;Var&gt;Buyer&lt;/Var&gt;&lt;/declare&gt;
         &lt;formula&gt;
           &lt;Atom&gt;
             &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;purchase&lt;/Const&gt;&lt;/op&gt;
             &lt;args ordered="yes"&gt;
               &lt;Var&gt;Buyer&lt;/Var&gt;
               &lt;Var&gt;Seller&lt;/Var&gt;
               &lt;Expr&gt;
                 &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;book&lt;/Const&gt;&lt;/op&gt;
                 &lt;args ordered="yes"&gt;
                   &lt;Var&gt;Author&lt;/Var&gt;
                   &lt;Const type="&amp;rif;iri"&gt;&amp;bks;LeRif&lt;/Const&gt;
                 &lt;/args&gt;
               &lt;/Expr&gt;
               &lt;Expr&gt;
                 &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;curr;USD&lt;/Const&gt;&lt;/op&gt;
                 &lt;args ordered="yes"&gt;&lt;Const type="&amp;xs;integer"&gt;49&lt;/Const&gt;&lt;/args&gt;
               &lt;/Expr&gt;
             &lt;/args&gt;
           &lt;/Atom&gt;
         &lt;/formula&gt;
       &lt;/Exists&gt;
     &lt;/formula&gt;
     &lt;formula&gt;
       &lt;Equal&gt;
         &lt;left&gt;&lt;Var&gt;Seller&lt;/Var&gt;&lt;/left&gt;
         &lt;right&gt;&lt;Var&gt;Author&lt;/Var&gt;&lt;/right&gt;
       &lt;/Equal&gt;
     &lt;/formula&gt;
   &lt;/And&gt;
</pre>
<p><br>
<span id="ex-rif-bld-namedargs-pres-syntax" class="anchor">
<b>Example 7</b> (An XML serialization of a RIF condition with a frame and a named-argument term).
</span>
</p><p>This example illustrates XML serialization of RIF conditions
that involve terms with named arguments. As in Example 6, we assume the
following prefix directives, whose XML form will be illustrated in
Example 8:
</p>
<pre>Prefix(bks    &lt;http://example.com/books#&gt;)
Prefix(cpt    &lt;http://example.com/concepts#&gt;)
Prefix(curr   &lt;http://example.com/currencies#&gt;)
Prefix(rif    &lt;http://www.w3.org/2007/rif#&gt;)
Prefix(xs     &lt;http://www.w3.org/2001/XMLSchema#&gt;)
</pre>
<p>RIF condition:
</p>
<pre>   And (Exists&nbsp;?Buyer&nbsp;?P (
                 And (?P#cpt:purchase
                     &nbsp;?P[cpt:buyer-&gt;?Buyer
                         cpt:seller-&gt;?Seller
                         cpt:item-&gt;cpt:book(cpt:author-&gt;?Author cpt:title-&gt;bks:LeRif)
                         cpt:price-&gt;49
                         cpt:currency-&gt;curr:USD]))
       &nbsp;?Seller=?Author)


</pre>
<p>XML serialization:
</p>
<pre>   &lt;And&gt;
     &lt;formula&gt;
       &lt;Exists&gt;
         &lt;declare&gt;&lt;Var&gt;Buyer&lt;/Var&gt;&lt;/declare&gt;
         &lt;declare&gt;&lt;Var&gt;P&lt;/Var&gt;&lt;/declare&gt;
         &lt;formula&gt;
           &lt;And&gt;
             &lt;formula&gt;
               &lt;Member&gt;
                 &lt;instance&gt;&lt;Var&gt;P&lt;/Var&gt;&lt;/instance&gt;
                 &lt;class&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;purchase&lt;/Const&gt;&lt;/class&gt;
               &lt;/Member&gt;
             &lt;/formula&gt;
             &lt;formula&gt;
               &lt;Frame&gt;
                 &lt;object&gt;
                   &lt;Var&gt;P&lt;/Var&gt;
                 &lt;/object&gt;
                 &lt;slot ordered="yes"&gt;
                   &lt;Const type="&amp;rif;iri"&gt;&amp;cpt;buyer&lt;/Const&gt;
                   &lt;Var&gt;Buyer&lt;/Var&gt;
                 &lt;/slot&gt;
                 &lt;slot ordered="yes"&gt;
                   &lt;Const type="&amp;rif;iri"&gt;&amp;cpt;seller&lt;/Const&gt;
                   &lt;Var&gt;Seller&lt;/Var&gt;
                 &lt;/slot&gt;
                 &lt;slot ordered="yes"&gt;
                   &lt;Const type="&amp;rif;iri"&gt;&amp;cpt;item&lt;/Const&gt;
                   &lt;Expr&gt;
                     &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;book&lt;/Const&gt;&lt;/op&gt;
                     &lt;slot ordered="yes"&gt;
                       &lt;Name&gt;&amp;cpt;author&lt;/Name&gt;
                       &lt;Var&gt;Author&lt;/Var&gt;
                     &lt;/slot&gt;
                     &lt;slot ordered="yes"&gt;
                       &lt;Name&gt;&amp;cpt;title&lt;/Name&gt;
                       &lt;Const type="&amp;rif;iri"&gt;&amp;bks;LeRif&lt;/Const&gt;
                     &lt;/slot&gt;
                   &lt;/Expr&gt;
                 &lt;/slot&gt;
                 &lt;slot ordered="yes"&gt;
                   &lt;Const type="&amp;rif;iri"&gt;&amp;cpt;price&lt;/Const&gt;
                   &lt;Const type="&amp;xs;integer"&gt;49&lt;/Const&gt;
                 &lt;/slot&gt;
                 &lt;slot ordered="yes"&gt;
                   &lt;Const type="&amp;rif;iri"&gt;&amp;cpt;currency&lt;/Const&gt;
                   &lt;Const type="&amp;rif;iri"&gt;&amp;curr;USD&lt;/Const&gt;
                 &lt;/slot&gt;
               &lt;/Frame&gt;
             &lt;/formula&gt;
           &lt;/And&gt;
         &lt;/formula&gt;
       &lt;/Exists&gt;
     &lt;/formula&gt;
     &lt;formula&gt;
       &lt;Equal&gt;
         &lt;left&gt;&lt;Var&gt;Seller&lt;/Var&gt;&lt;/left&gt;
         &lt;right&gt;&lt;Var&gt;Author&lt;/Var&gt;&lt;/right&gt;
       &lt;/Equal&gt;
     &lt;/formula&gt;
   &lt;/And&gt;
</pre>
<p><br>
</p><p><span id="sec-xml-rule-language" class="anchor"></span>
</p>
<a name="XML_for_the_Rule_Language"></a><h3> <span class="mw-headline">4.2  XML for the Rule Language </span></h3>
<p>We now extend the set of RIF-BLD serialization elements from Section <a href="#sec-xml-condition-language" title="">XML for RIF-BLD Condition Language</a> by including rules, along with their enclosing groups and documents, as described in Section <a href="#sec-ebnf-rule-language" title="">EBNF for RIF-BLD Rule Language</a>. The extended set includes the tags listed below. While there is a RIF-BLD element tag for the <tt>Import</tt> directive, there are none for the <tt>Prefix</tt> and <tt>Base</tt> directives: they are handled as discussed in Section <a href="#sec-translation-rule-language" title="">Mapping of the RIF-BLD Rule Language</a>.
</p><p><br>
</p>
<pre>- Document  (document, containing optional directive and payload roles)
- directive (directive role, containing Import)
- payload   (payload role, containing Group)
- Import    (importation, containing location and optional profile)
- location  (location role, containing ANYURICONST)
- profile   (profile role, containing PROFILE)
- Group     (nested collection of sentences)
- sentence  (sentence role, containing RULE or Group)
- Forall    (quantified formula for 'Forall', containing declare and formula roles)
- Implies   (implication, containing if and then roles)
- if        (antecedent role, containing FORMULA)
- then      (consequent role, containing ATOMIC or conjunction of ATOMICs)
</pre>
<p>The XML Schema Definition of RIF-BLD is given in Appendix <a href="#sec-xsd-bld" title="">XML Schema for BLD</a>.
</p><p><br>
<span id="ex-RIF-doc-with-annotation-serialization" class="anchor">
<b>Example 8</b> (Serializing a RIF-BLD document containing an annotated group).
</span> 
</p><p>This example shows a serialization for the document from Example
5. For convenience, the document is reproduced at the top and then is
followed by its serialization.
</p><p>Presentation syntax:
</p>
<pre>Document(
  Prefix(ppl  &lt;http://example.com/people#&gt;)
  Prefix(cpt  &lt;http://example.com/concepts#&gt;)
  Prefix(dc   &lt;http://purl.org/dc/terms/&gt;)
  Prefix(rif  &lt;http://www.w3.org/2007/rif#&gt;)
  Prefix(func &lt;http://www.w3.org/2007/rif-builtin-function#&gt;)
  Prefix(pred &lt;http://www.w3.org/2007/rif-builtin-predicate#&gt;)
  Prefix(xs   &lt;http://www.w3.org/2001/XMLSchema#&gt;)
  
  (* "http://sample.org"^^rif:iri _pd[dc:publisher -&gt; "http://www.w3.org/"^^rif:iri
                                      dc:date -&gt; "2008-04-04"^^xs:date] *)
  Group
  (
    Forall&nbsp;?item&nbsp;?deliverydate&nbsp;?scheduledate&nbsp;?diffduration&nbsp;?diffdays (
        cpt:reject(ppl:John&nbsp;?item)&nbsp;:-
            And(cpt:perishable(?item)
                cpt:delivered(?item&nbsp;?deliverydate ppl:John)
                cpt:scheduled(?item&nbsp;?scheduledate)
               &nbsp;?diffduration = External(func:subtract-dateTimes(?deliverydate&nbsp;?scheduledate))
               &nbsp;?diffdays = External(func:days-from-duration(?diffduration))
                External(pred:numeric-greater-than(?diffdays 10)))
    )
 
    Forall&nbsp;?item (
        cpt:reject(ppl:Fred&nbsp;?item)&nbsp;:- cpt:unsolicited(?item)
    )
  )
)


</pre>
<p>XML syntax:
</p>
<pre>&lt;!DOCTYPE Document [
  &lt;!ENTITY ppl  "http://example.com/people#"&gt;
  &lt;!ENTITY cpt  "http://example.com/concepts#"&gt;
  &lt;!ENTITY dc   "http://purl.org/dc/terms/"&gt;
  &lt;!ENTITY rif  "http://www.w3.org/2007/rif#"&gt;
  &lt;!ENTITY func "http://www.w3.org/2007/rif-builtin-function#"&gt;
  &lt;!ENTITY pred "http://www.w3.org/2007/rif-builtin-predicate#"&gt;
  &lt;!ENTITY xs   "http://www.w3.org/2001/XMLSchema#"&gt;
]&gt;

&lt;Document 
    xmlns="http://www.w3.org/2007/rif#"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:xs="http://www.w3.org/2001/XMLSchema#"&gt;
  &lt;payload&gt;
   &lt;Group&gt;
    &lt;id&gt;
      &lt;Const type="&amp;rif;iri"&gt;http://sample.org&lt;/Const&gt;
    &lt;/id&gt;
    &lt;meta&gt;
      &lt;Frame&gt;
        &lt;object&gt;
          &lt;Const type="&amp;rif;local"&gt;pd&lt;/Const&gt;
        &lt;/object&gt;
        &lt;slot ordered="yes"&gt;
          &lt;Const type="&amp;rif;iri"&gt;&amp;dc;publisher&lt;/Const&gt;
          &lt;Const type="&amp;rif;iri"&gt;http://www.w3.org/&lt;/Const&gt;
        &lt;/slot&gt;
        &lt;slot ordered="yes"&gt;
          &lt;Const type="&amp;rif;iri"&gt;&amp;dc;date&lt;/Const&gt;
          &lt;Const type="&amp;xs;date"&gt;2008-04-04&lt;/Const&gt;
        &lt;/slot&gt;
      &lt;/Frame&gt;
    &lt;/meta&gt;
    &lt;sentence&gt;
     &lt;Forall&gt;
       &lt;declare&gt;&lt;Var&gt;item&lt;/Var&gt;&lt;/declare&gt;
       &lt;declare&gt;&lt;Var&gt;deliverydate&lt;/Var&gt;&lt;/declare&gt;
       &lt;declare&gt;&lt;Var&gt;scheduledate&lt;/Var&gt;&lt;/declare&gt;
       &lt;declare&gt;&lt;Var&gt;diffduration&lt;/Var&gt;&lt;/declare&gt;
       &lt;declare&gt;&lt;Var&gt;diffdays&lt;/Var&gt;&lt;/declare&gt;
       &lt;formula&gt;
         &lt;Implies&gt;
           &lt;if&gt;
             &lt;And&gt;
               &lt;formula&gt;
                 &lt;Atom&gt;
                   &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;perishable&lt;/Const&gt;&lt;/op&gt;
                   &lt;args ordered="yes"&gt;&lt;Var&gt;item&lt;/Var&gt;&lt;/args&gt;
                 &lt;/Atom&gt;
               &lt;/formula&gt;
               &lt;formula&gt;
                 &lt;Atom&gt;
                   &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;delivered&lt;/Const&gt;&lt;/op&gt;
                   &lt;args ordered="yes"&gt;
                     &lt;Var&gt;item&lt;/Var&gt;
                     &lt;Var&gt;deliverydate&lt;/Var&gt;
                     &lt;Const type="&amp;rif;iri"&gt;&amp;ppl;John&lt;/Const&gt;
                   &lt;/args&gt;
                 &lt;/Atom&gt;
               &lt;/formula&gt;
               &lt;formula&gt;
                 &lt;Atom&gt;
                   &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;scheduled&lt;/Const&gt;&lt;/op&gt;
                   &lt;args ordered="yes"&gt;
                     &lt;Var&gt;item&lt;/Var&gt;
                     &lt;Var&gt;scheduledate&lt;/Var&gt;
                   &lt;/args&gt;
                 &lt;/Atom&gt;
               &lt;/formula&gt;
               &lt;formula&gt;
                 &lt;Equal&gt;
                   &lt;left&gt;&lt;Var&gt;diffduration&lt;/Var&gt;&lt;/left&gt;
                   &lt;right&gt;
                     &lt;External&gt;
                       &lt;content&gt;
                         &lt;Expr&gt;
                           &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;func;subtract-dateTimes&lt;/Const&gt;&lt;/op&gt;
                           &lt;args ordered="yes"&gt;
                             &lt;Var&gt;deliverydate&lt;/Var&gt;
                             &lt;Var&gt;scheduledate&lt;/Var&gt;
                           &lt;/args&gt;
                         &lt;/Expr&gt;
                       &lt;/content&gt;
                     &lt;/External&gt;
                   &lt;/right&gt;
                 &lt;/Equal&gt;
               &lt;/formula&gt;
               &lt;formula&gt;
                 &lt;Equal&gt;
                   &lt;left&gt;&lt;Var&gt;diffdays&lt;/Var&gt;&lt;/left&gt;
                   &lt;right&gt;
                     &lt;External&gt;
                       &lt;content&gt;
                         &lt;Expr&gt;
                           &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;func;days-from-duration&lt;/Const&gt;&lt;/op&gt;
                           &lt;args ordered="yes"&gt;
                             &lt;Var&gt;diffduration&lt;/Var&gt;
                           &lt;/args&gt;
                         &lt;/Expr&gt;
                       &lt;/content&gt;
                     &lt;/External&gt;
                   &lt;/right&gt;
                 &lt;/Equal&gt;
               &lt;/formula&gt;
               &lt;formula&gt;
                 &lt;External&gt;
                   &lt;content&gt;
                     &lt;Atom&gt;
                       &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;pred;numeric-greater-than&lt;/Const&gt;&lt;/op&gt;
                       &lt;args ordered="yes"&gt;
                         &lt;Var&gt;diffdays&lt;/Var&gt;
                         &lt;Const type="&amp;xs;integer"&gt;10&lt;/Const&gt;
                       &lt;/args&gt;
                     &lt;/Atom&gt;
                   &lt;/content&gt;
                 &lt;/External&gt;
               &lt;/formula&gt;
             &lt;/And&gt;
           &lt;/if&gt;
           &lt;then&gt;
             &lt;Atom&gt;
               &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;reject&lt;/Const&gt;&lt;/op&gt;
               &lt;args ordered="yes"&gt;
                 &lt;Const type="&amp;rif;iri"&gt;&amp;ppl;John&lt;/Const&gt;
                 &lt;Var&gt;item&lt;/Var&gt;
               &lt;/args&gt;
             &lt;/Atom&gt;
           &lt;/then&gt;
         &lt;/Implies&gt;
       &lt;/formula&gt;
     &lt;/Forall&gt;
    &lt;/sentence&gt;
    &lt;sentence&gt;
     &lt;Forall&gt;
       &lt;declare&gt;&lt;Var&gt;item&lt;/Var&gt;&lt;/declare&gt;
       &lt;formula&gt;
         &lt;Implies&gt;
           &lt;if&gt;
             &lt;Atom&gt;
               &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;unsolicited&lt;/Const&gt;&lt;/op&gt;
               &lt;args ordered="yes"&gt;&lt;Var&gt;item&lt;/Var&gt;&lt;/args&gt;
             &lt;/Atom&gt;
           &lt;/if&gt;
           &lt;then&gt;
             &lt;Atom&gt;
               &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;reject&lt;/Const&gt;&lt;/op&gt;
               &lt;args ordered="yes"&gt;
                 &lt;Const type="&amp;rif;iri"&gt;&amp;ppl;Fred&lt;/Const&gt;
                 &lt;Var&gt;item&lt;/Var&gt;
               &lt;/args&gt;
             &lt;/Atom&gt;
           &lt;/then&gt;
         &lt;/Implies&gt;
       &lt;/formula&gt;
     &lt;/Forall&gt;
    &lt;/sentence&gt;
   &lt;/Group&gt;
  &lt;/payload&gt;
 &lt;/Document&gt;
</pre>
<p><br>
</p><p><span id="sec-translation" class="anchor"></span>
</p>
<a name="Mapping_from_the_Presentation_Syntax_to_the_XML_Syntax"></a><h3> <span class="mw-headline">4.3  Mapping from the Presentation Syntax to the XML Syntax </span></h3>
<p>This section defines a normative mapping, <tt>χ<sub>bld</sub></tt>,
from the presentation syntax to the XML syntax of RIF-BLD.
The mapping is given via tables where each row specifies the mapping of
a particular syntactic pattern in the presentation syntax. These
patterns appear in the first column of the tables and the <i><b>bold-italic</b></i>
symbols represent metavariables. The second column represents the
corresponding XML patterns, which may contain applications of the
mapping <tt>χ<sub>bld</sub></tt> to these metavariables. When an expression <tt>χ<sub>bld</sub></tt><tt>(<b><i>metavar</i></b>)</tt> occurs in an XML pattern in the right column of a translation table, it should be understood as a recursive application of <tt>χ<sub>bld</sub></tt>
to the presentation syntax represented by the metavariable. The XML
syntax result of such an application is substituted for the expression <tt>χ<sub>bld</sub></tt><tt>(<b><i>metavar</i></b>)</tt>. 
A sequence of terms containing metavariables with subscripts is indicated by an ellipsis.
For the subscript <tt>m</tt> it is understood that
<tt>m≥1</tt>, i.e. the ellipsis indicates at least one term.
For the subscript <tt>n</tt> it is understood that
<tt>n≥0</tt>, i.e. the ellipsis indicates zero or more terms.
A metavariable or a well-formed XML subelement is marked as optional by appending a bold-italic question mark, <i><b>?</b></i>, on its right.
</p><p><br>
<span id="sec-translation-condition-language" class="anchor"></span> 
</p>
<a name="Mapping_of_the_Condition_Language"></a><h4> <span class="mw-headline">4.3.1  Mapping of the Condition Language </span></h4>
<p>The <tt>χ<sub>bld</sub></tt> mapping from the presentation syntax to the XML syntax of the RIF-BLD Condition Language is specified by the table below. 
Each row indicates a translation
<tt>χ<sub>bld</sub></tt>(<tt>Presentation</tt>) = <tt>XML</tt>.
Since the presentation syntax of RIF-BLD is context sensitive, the
mapping must differentiate between the terms that occur in the position
of individuals and the terms that occur as atomic formulas. To this
end, in the translation table, the positional and named-argument terms
that occur in the context of atomic formulas are denoted by expressions
of the form <i><b>pred</b></i>(...) and the terms that occur as individuals are denoted by expressions of the form <i><b>func</b></i>(...).
In the table, each metavariable for an (unnamed) positional <i><b>argument<sub>i</sub></b></i> is assumed to be instantiated to values unequal to the instantiations of named arguments <i><b>unicodestring<sub>j</sub></b></i> <tt>-&gt;</tt> <i><b>filler<sub>j</sub></b></i>. Regarding the last but first row, we assume that shortcuts for constants [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] have already been expanded to their full form (<tt>"..."^^</tt><i><b>symspace</b></i>).
</p>
<table class="syntax-translation-table">
<tbody><tr>
<th rowspan="1" colspan="1"> Presentation Syntax
</th><th rowspan="1" colspan="1"> XML Syntax
</th></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>And (
  <i><b>conjunct<sub>1</sub></b></i>
  . . .
  <i><b>conjunct<sub>n</sub></b></i>
    )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;And&gt;
  &lt;formula&gt;<tt>χ<sub>bld</sub></tt>(<i><b>conjunct<sub>1</sub></b></i>)&lt;/formula&gt;
   . . .
  &lt;formula&gt;<tt>χ<sub>bld</sub></tt>(<i><b>conjunct<sub>n</sub></b></i>)&lt;/formula&gt;
&lt;/And&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>Or (
  <i><b>disjunct<sub>1</sub></b></i>
  . . .
  <i><b>disjunct<sub>n</sub></b></i>
   )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Or&gt;
  &lt;formula&gt;<tt>χ<sub>bld</sub></tt>(<i><b>disjunct<sub>1</sub></b></i>)&lt;/formula&gt;
   . . .
  &lt;formula&gt;<tt>χ<sub>bld</sub></tt>(<i><b>disjunct<sub>n</sub></b></i>)&lt;/formula&gt;
&lt;/Or&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>Exists
  <i><b>variable<sub>1</sub></b></i>
  . . .
  <i><b>variable<sub>n</sub></b></i> (
             <i><b>premise</b></i>
            )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Exists&gt;
  &lt;declare&gt;<tt>χ<sub>bld</sub></tt>(<i><b>variable<sub>1</sub></b></i>)&lt;/declare&gt;
   . . .
  &lt;declare&gt;<tt>χ<sub>bld</sub></tt>(<i><b>variable<sub>n</sub></b></i>)&lt;/declare&gt;
  &lt;formula&gt;<tt>χ<sub>bld</sub></tt>(<i><b>premise</b></i>)&lt;/formula&gt;
&lt;/Exists&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>External (
  <i><b>atomexpr</b></i>
         )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;External&gt;
  &lt;content&gt;<tt>χ<sub>bld</sub></tt>(<i><b>atomexpr</b></i>)&lt;/content&gt;
&lt;/External&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre><i><b>pred</b></i> (
  <i><b>argument<sub>1</sub></b></i>
  . . .
  <i><b>argument<sub>n</sub></b></i>
     )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Atom&gt;
  &lt;op&gt;<tt>χ<sub>bld</sub></tt>(<i><b>pred</b></i>)&lt;/op&gt;
  &lt;args ordered="yes"&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>argument<sub>1</sub></b></i>)
    . . .
    <tt>χ<sub>bld</sub></tt>(<i><b>argument<sub>n</sub></b></i>)
  &lt;/args&gt;
&lt;/Atom&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre><i><b>func</b></i> (
  <i><b>argument<sub>1</sub></b></i>
  . . .
  <i><b>argument<sub>n</sub></b></i>
     )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Expr&gt;
  &lt;op&gt;<tt>χ<sub>bld</sub></tt>(<i><b>func</b></i>)&lt;/op&gt;
  &lt;args ordered="yes"&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>argument<sub>1</sub></b></i>)
    . . .
    <tt>χ<sub>bld</sub></tt>(<i><b>argument<sub>n</sub></b></i>)
  &lt;/args&gt;
&lt;/Expr&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>List (
  <i><b>element<sub>1</sub></b></i>
  . . .
  <i><b>element<sub>n</sub></b></i>
    )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;List&gt;
  <tt>χ<sub>bld</sub></tt>(<i><b>element<sub>1</sub></b></i>)
  . . .
  <tt>χ<sub>bld</sub></tt>(<i><b>element<sub>n</sub></b></i>)
&lt;/List&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>List (
  <i><b>element<sub>1</sub></b></i>
  . . .
  <i><b>element<sub>m</sub></b></i>
  |
  <i><b>remainder</b></i>
    )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;List&gt;
  <tt>χ<sub>bld</sub></tt>(<i><b>element<sub>1</sub></b></i>)
  . . .
  <tt>χ<sub>bld</sub></tt>(<i><b>element<sub>m</sub></b></i>)
  &lt;rest&gt;<tt>χ<sub>bld</sub></tt>(<i><b>remainder</b></i>)&lt;/rest&gt;
&lt;/List&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre><i><b>pred</b></i> (
  <i><b>unicodestring<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>unicodestring<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Atom&gt;
  &lt;op&gt;<tt>χ<sub>bld</sub></tt>(<i><b>pred</b></i>)&lt;/op&gt;
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<i><b>unicodestring<sub>1</sub></b></i>&lt;/Name&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<i><b>unicodestring<sub>n</sub></b></i>&lt;/Name&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Atom&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre><i><b>func</b></i> (
  <i><b>unicodestring<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>unicodestring<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Expr&gt;
  &lt;op&gt;<tt>χ<sub>bld</sub></tt>(<i><b>func</b></i>)&lt;/op&gt;
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<i><b>unicodestring<sub>1</sub></b></i>&lt;/Name&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<i><b>unicodestring<sub>n</sub></b></i>&lt;/Name&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Expr&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre><i><b>inst</b></i> [
  <i><b>key<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>key<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     ]
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Frame&gt;
  &lt;object&gt;<tt>χ<sub>bld</sub></tt>(<i><b>inst</b></i>)&lt;/object&gt;
  &lt;slot ordered="yes"&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>key<sub>1</sub></b></i>)
    <tt>χ<sub>bld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>key<sub>n</sub></b></i>)
    <tt>χ<sub>bld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Frame&gt;
</pre>
</td></tr>

<tr>
<td rowspan="1" colspan="1">
<pre><i><b>inst</b></i> # <i><b>class</b></i>
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Member&gt;
  &lt;instance&gt;<tt>χ<sub>bld</sub></tt>(<i><b>inst</b></i>)&lt;/instance&gt;
  &lt;class&gt;<tt>χ<sub>bld</sub></tt>(<i><b>class</b></i>)&lt;/class&gt;
&lt;/Member&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre><i><b>sub</b></i> ## <i><b>super</b></i>
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Subclass&gt;
  &lt;sub&gt;<tt>χ<sub>bld</sub></tt>(<i><b>sub</b></i>)&lt;/sub&gt;
  &lt;super&gt;<tt>χ<sub>bld</sub></tt>(<i><b>super</b></i>)&lt;/super&gt;
&lt;/Subclass&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre><i><b>left</b></i> = <i><b>right</b></i>
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Equal&gt;
  &lt;left&gt;<tt>χ<sub>bld</sub></tt>(<i><b>left</b></i>)&lt;/left&gt;
  &lt;right&gt;<tt>χ<sub>bld</sub></tt>(<i><b>right</b></i>)&lt;/right&gt;
&lt;/Equal&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>"<i><b>unicodestring</b></i>"^^<i><b>symspace</b></i>
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Const type="<i><b>symspace</b></i>"&gt;<i><b>unicodestring</b></i>&lt;/Const&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>?<i><b>unicodestring</b></i>
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Var&gt;<i><b>unicodestring</b></i>&lt;/Var&gt;
</pre>
</td></tr></tbody></table>
<p><br>
<span id="sec-translation-rule-language" class="anchor"></span>
</p>
<a name="Mapping_of_the_Rule_Language"></a><h4> <span class="mw-headline">4.3.2  Mapping of the Rule Language </span></h4>
<p>The <tt>χ<sub>bld</sub></tt> mapping from the presentation syntax to
the XML syntax of the RIF-BLD Rule Language is specified by the table
below. It extends the translation table of Section <a href="#sec-translation-condition-language" title="">Mapping of the Condition Language</a>. While the <tt>Import</tt> directive is handled by the presentation-to-XML syntax mapping, the <tt>Prefix</tt> and <tt>Base</tt> directives are not. Instead, these directives should be handled by expanding the associated shortcuts (compact URIs).
Namely, a prefix name declared in a <tt>Prefix</tt> directive is expanded into the associated IRI, while relative IRIs are completed using the IRI declared in the <tt>Base</tt> directive. The mapping <tt>χ<sub>bld</sub></tt> applies only to such expanded documents.
RIF-BLD also allows other treatments of <tt>Prefix</tt> and <tt>Base</tt>
provided that they produce equivalent XML documents. One such treatment
is employed in the examples in this document, especially Example 8. It
replaces prefix names with definitions of XML entities as follows.
Each <tt>Prefix</tt> declaration becomes an <tt>ENTITY</tt> declaration [<a href="#ref-xml-1-point-0" title="">XML1.0</a>] within a <tt>DOCTYPE</tt> DTD attached to the RIF-BLD <tt>Document</tt>. The <tt>Base</tt> directive is mapped to the <tt>xml:base</tt> attribute [<a href="#ref-xml-base" title="">XML-Base</a>] in the XML <tt>Document</tt> tag.
Compact URIs of the form <tt>prefix:suffix</tt> are then mapped to <tt>&amp;prefix;suffix</tt>.
</p>
<table class="syntax-translation-table">
<tbody><tr>
<th rowspan="1" colspan="1"> Presentation Syntax
</th><th rowspan="1" colspan="1"> XML Syntax
</th></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>Document(
  Import(<i><b>loc<sub>1</sub></b></i> <i><b>prfl<sub>1</sub>?</b></i>)
   . . .
  Import(<i><b>loc<sub>n</sub></b></i> <i><b>prfl<sub>n</sub>?</b></i>)
  <i><b>group?</b></i>
        )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Document&gt;
  &lt;directive&gt;
    &lt;Import&gt;
      &lt;location&gt;<tt>χ<sub>bld</sub></tt>(<i><b>loc<sub>1</sub></b></i>)&lt;/location&gt;
      &lt;profile&gt;<tt>χ<sub>bld</sub></tt>(<i><b>prfl<sub>1</sub></b></i>)&lt;/profile&gt;<i><b>?</b></i>
    &lt;/Import&gt;
  &lt;/directive&gt;
   . . .
  &lt;directive&gt;
    &lt;Import&gt;
      &lt;location&gt;<tt>χ<sub>bld</sub></tt>(<i><b>loc<sub>n</sub></b></i>)&lt;/location&gt;
      &lt;profile&gt;<tt>χ<sub>bld</sub></tt>(<i><b>prfl<sub>n</sub></b></i>)&lt;/profile&gt;<i><b>?</b></i>
    &lt;/Import&gt;
  &lt;/directive&gt;
  &lt;payload&gt;<tt>χ<sub>bld</sub></tt>(<i><b>group</b></i>)&lt;/payload&gt;<i><b>?</b></i>
&lt;/Document&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>Group(
  <i><b>clause<sub>1</sub></b></i>
   . . .
  <i><b>clause<sub>n</sub></b></i>
     )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Group&gt;
  &lt;sentence&gt;<tt>χ<sub>bld</sub></tt>(<i><b>clause<sub>1</sub></b></i>)&lt;/sentence&gt;
   . . .
  &lt;sentence&gt;<tt>χ<sub>bld</sub></tt>(<i><b>clause<sub>n</sub></b></i>)&lt;/sentence&gt;
&lt;/Group&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>Forall
  <i><b>variable<sub>1</sub></b></i>
   . . .
  <i><b>variable<sub>n</sub></b></i> (
             <i><b>rule</b></i>
            )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Forall&gt;
  &lt;declare&gt;<tt>χ<sub>bld</sub></tt>(<i><b>variable<sub>1</sub></b></i>)&lt;/declare&gt;
   . . .
  &lt;declare&gt;<tt>χ<sub>bld</sub></tt>(<i><b>variable<sub>n</sub></b></i>)&lt;/declare&gt;
  &lt;formula&gt;<tt>χ<sub>bld</sub></tt>(<i><b>rule</b></i>)&lt;/formula&gt;
&lt;/Forall&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre><i><b>conclusion</b></i>&nbsp;:- <i><b>condition</b></i>
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Implies&gt;
  &lt;if&gt;<tt>χ<sub>bld</sub></tt>(<i><b>condition</b></i>)&lt;/if&gt;
  &lt;then&gt;<tt>χ<sub>bld</sub></tt>(<i><b>conclusion</b></i>)&lt;/then&gt;
&lt;/Implies&gt;
</pre>
</td></tr></tbody></table>
<a name="Mapping_of_Annotations"></a><h4> <span class="mw-headline">4.3.3  Mapping of Annotations </span></h4>
<p>The <tt>χ<sub>bld</sub></tt> mapping from RIF-BLD annotations in the presentation syntax to the XML syntax is specified by the table below.
It extends the translation tables of Sections <a href="#sec-translation-condition-language" title="">Mapping of the Condition Language</a> and <a href="#sec-translation-rule-language" title="">Mapping of the Rule Language</a>.
The metavariable <i><b>Typetag</b></i> in the presentation and XML syntaxes stands for any of the class names <tt>And</tt>, <tt>Or</tt>, <tt>External</tt>, <tt>Document</tt>, or <tt>Group</tt>, and <i><b>Quantifier</b></i> for <tt>Exists</tt> or <tt>Forall</tt>. The dollar sign, <b>$</b>, stands for any of the binary infix operator names <tt>#</tt>, <tt>##</tt>, <tt>=</tt>, or <tt>:-</tt>, while <i><b>Binop</b></i> stands for their respective class names <tt>Member</tt>, <tt>Subclass</tt>, <tt>Equal</tt>, or <tt>Implies</tt>.
Again, each metavariable for an (unnamed) positional <i><b>argument<sub>i</sub></b></i> is assumed to be instantiated to values unequal to the instantiations of named arguments <i><b>unicodestring<sub>j</sub></b></i> <tt>-&gt;</tt> <i><b>filler<sub>j</sub></b></i>.
</p>
<table class="syntax-translation-table">
<tbody><tr>
<th rowspan="1" colspan="1"> Presentation Syntax
</th><th rowspan="1" colspan="1"> XML Syntax
</th></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>Typetag</b></i> ( <i><b>e<sub>1</sub></b></i> . . . <i><b>e<sub>n</sub></b></i> )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;<i><b>Typetag</b></i>&gt;
  &lt;id&gt;<tt>χ<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>χ<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  <i><b>e<sub>1</sub>'</b></i> . . . <i><b>e<sub>n</sub>'</b></i>
&lt;/<i><b>Typetag</b></i>&gt;

<tt>where <i><b>e<sub>1</sub>'</b></i>, . . ., <i><b>e<sub>n</sub>'</b></i> are defined by the equation</tt>
<tt>χ<sub>bld</sub></tt><tt>(<i><b>Typetag</b></i>(<i><b>e<sub>1</sub></b></i> . . . <i><b>e<sub>n</sub></b></i>)) = &lt;<i><b>Typetag</b></i>&gt;<i><b>e<sub>1</sub>'</b></i> . . . <i><b>e<sub>n</sub>'</b></i>&lt;/<i><b>Typetag</b></i>&gt;</tt>
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>Quantifier</b></i> <i><b>variable<sub>1</sub></b></i> . . . <i><b>variable<sub>n</sub></b></i> ( <i><b>formula</b></i> )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;<i><b>Quantifier</b></i>&gt;
  &lt;id&gt;<tt>χ<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>χ<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;declare&gt;<tt>χ<sub>bld</sub></tt>(<i><b>variable<sub>1</sub></b></i>)&lt;/declare&gt;
  . . .
  &lt;declare&gt;<tt>χ<sub>bld</sub></tt>(<i><b>variable<sub>n</sub></b></i>)&lt;/declare&gt;
  &lt;formula&gt;<tt>χ<sub>bld</sub></tt>(<i><b>formula</b></i>)&lt;/formula&gt;
&lt;/<i><b>Quantifier</b></i>&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>pred</b></i> (
  <i><b>argument<sub>1</sub></b></i>
  . . .
  <i><b>argument<sub>n</sub></b></i>
     )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Atom&gt;
  &lt;id&gt;<tt>χ<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>χ<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;op&gt;<tt>χ<sub>bld</sub></tt>(<i><b>pred</b></i>)&lt;/op&gt;
  &lt;args ordered="yes"&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>argument<sub>1</sub></b></i>)
    . . .
    <tt>χ<sub>bld</sub></tt>(<i><b>argument<sub>n</sub></b></i>)
  &lt;/args&gt;
&lt;/Atom&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>func</b></i> (
  <i><b>argument<sub>1</sub></b></i>
  . . .
  <i><b>argument<sub>n</sub></b></i>
     )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Expr&gt;
  &lt;id&gt;<tt>χ<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>χ<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;op&gt;<tt>χ<sub>bld</sub></tt>(<i><b>func</b></i>)&lt;/op&gt;
  &lt;args ordered="yes"&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>argument<sub>1</sub></b></i>)
    . . .
    <tt>χ<sub>bld</sub></tt>(<i><b>argument<sub>n</sub></b></i>)
  &lt;/args&gt;
&lt;/Expr&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>pred</b></i> (
  <i><b>unicodestring<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>unicodestring<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Atom&gt;
  &lt;id&gt;<tt>χ<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>χ<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;op&gt;<tt>χ<sub>bld</sub></tt>(<i><b>pred</b></i>)&lt;/op&gt;
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<i><b>unicodestring<sub>1</sub></b></i>&lt;/Name&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<i><b>unicodestring<sub>n</sub></b></i>&lt;/Name&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Atom&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>func</b></i> (
  <i><b>unicodestring<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>unicodestring<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     )
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Expr&gt;
  &lt;id&gt;<tt>χ<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>χ<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;op&gt;<tt>χ<sub>bld</sub></tt>(<i><b>func</b></i>)&lt;/op&gt;
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<i><b>unicodestring<sub>1</sub></b></i>&lt;/Name&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<i><b>unicodestring<sub>n</sub></b></i>&lt;/Name&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Expr&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>inst</b></i> [
  <i><b>key<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>key<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     ]
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Frame&gt;
  &lt;id&gt;<tt>χ<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>χ<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;object&gt;<tt>χ<sub>bld</sub></tt>(<i><b>inst</b></i>)&lt;/object&gt;
  &lt;slot ordered="yes"&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>key<sub>1</sub></b></i>)
    <tt>χ<sub>bld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    <tt>χ<sub>bld</sub></tt>(<i><b>key<sub>n</sub></b></i>)
    <tt>χ<sub>bld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Frame&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>e<sub>1</sub></b></i> <b>$</b> <i><b>e<sub>2</sub></b></i>
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;<i><b>Binop</b></i>&gt;
  &lt;id&gt;<tt>χ<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>χ<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  <i><b>e<sub>1</sub>'</b></i> <i><b>e<sub>2</sub>'</b></i>
&lt;/<i><b>Binop</b></i>&gt;

<tt>where <i><b>Binop</b></i>, <i><b>e<sub>1</sub>'</b></i>, <i><b>e<sub>2</sub>'</b></i> are defined by the equation</tt>
<tt>χ<sub>bld</sub></tt><tt>(<i><b>e<sub>1</sub></b></i> <b>$</b> <i><b>e<sub>2</sub></b></i>) = &lt;<i><b>Binop</b></i>&gt;<i><b>e<sub>1</sub>'</b></i> <i><b>e<sub>2</sub>'</b></i>&lt;/<i><b>Binop</b></i>&gt;</tt>
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>unicodestring</b></i>^^<i><b>symspace</b></i>
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Const type="<i><b>symspace</b></i>"&gt;
  &lt;id&gt;<tt>χ<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>χ<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  <i><b>unicodestring</b></i>
&lt;/Const&gt;
</pre>
</td></tr>
<tr>
<td rowspan="1" colspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
?<i><b>unicodestring</b></i>
</pre>
</td><td rowspan="1" colspan="1">
<pre>&lt;Var&gt;
  &lt;id&gt;<tt>χ<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>χ<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  <i><b>unicodestring</b></i>
&lt;/Var&gt;
</pre>
</td></tr></tbody></table>
<p><br>
<span id="sec-conformance" class="anchor"></span>
</p>
<a name="Conformance_Clauses"></a><h2> <span class="mw-headline">5  Conformance Clauses </span></h2>
<p>RIF-BLD does not require or expect conformant systems to implement
the RIF-BLD presentation syntax. Instead, conformance is described in
terms of semantics-preserving transformations between the native syntax
of a compliant system and the XML syntax of RIF-BLD.
</p><p>Let Τ be a set of datatypes and symbol spaces that includes the datatypes specified in
[<a href="#ref-rif-dtb" title="">RIF-DTB</a>], and the symbol spaces <tt>rif:iri</tt>, and <tt>rif:local</tt>. Suppose Ε is a <a href="http://www.w3.org/2005/rules/wiki/DTB#def-external-schema-set" title="DTB">coherent set of external schemas</a> that includes the built-ins listed in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. We say that a formula φ is a <i>BLD</i><sub>Τ,Ε</sub> formula iff 
</p>
<ul>
  <li>
    it is a well-formed BLD formula,
  </li>
  <li>
    all datatypes and symbol spaces used in φ are in Τ, and
  </li>
  <li>
    all externally defined terms used in φ are instances of external schemas from Ε.
  </li>
</ul>
<p><span id="def-conformance" class="anchor"></span>
A RIF processor is a <i><b>conformant</b></i> <i>BLD</i><sub>Τ,Ε</sub> <i><b>consumer</b></i> iff it implements a <span id="def-sem-preserving-map-to" class="anchor"><i>semantics-preserving mapping</i></span>, μ, from the set of all <i>BLD</i><sub>Τ,Ε</sub> formulas to the language <i>L</i> of the processor (μ does not need to be an "onto" mapping).
</p><p>Formally, this means that for any pair φ, ψ of <i>BLD</i><sub>Τ,Ε</sub> formulas for which φ |=<sub><tt><i>BLD</i></tt></sub> ψ is defined, φ |=<sub><tt><i>BLD</i></tt></sub> ψ iff  μ(φ) |=<sub><tt><i>L</i></tt></sub> μ(ψ). Here |=<sub><tt><i>BLD</i></tt></sub> denotes the logical entailment in RIF-BLD and |=<sub><tt><i>L</i></tt></sub> is the logical entailment in the language <i>L</i> of the RIF processor.
</p><p>A RIF processor is a <i><b>conformant</b></i> <i>BLD</i><sub>Τ,Ε</sub> <i><b>producer</b></i> iff it implements a <span id="def-sem-preserving-map-from" class="anchor"><i>semantics-preserving mapping</i></span>, ν, from the language <i>L</i> of the processor to the set of all <i>BLD</i><sub>Τ,Ε</sub> formulas (ν does not need to be an "onto" mapping).
</p><p>Formally, this means that for any pair φ, ψ of formulas in <i>L</i> for which φ |=<sub><tt><i>L</i></tt></sub> ψ is defined, φ |=<sub><tt><i>L</i></tt></sub> ψ iff  ν(φ) |=<sub><tt><i>BLD</i></tt></sub> ν(ψ).
</p><p>An <i><b>admissible document</b></i> is one which conforms to
all the syntactic constraints of RIF-BLD, including ones that cannot be
checked by an XML Schema validator (cf. Definition <a href="#def-bld-admissible-xml" title="">Admissible BLD document in XML syntax</a>).
</p><p>The above definitions are specializations to BLD of the general
conformance clauses defined in the RIF framework for logic dialects [<a href="#ref-rif-fld" title="">RIF-FLD</a>]. The following clauses are further restrictions that are specific to RIF-BLD.
</p><p><b>RIF-BLD specific clauses</b>
</p>
<ul><li> Conformant BLD producers and consumers are required to support only the entailments of the form φ |=<sub><tt><i>BLD</i></tt></sub> ψ, where ψ is a <span id="ptr-closed-rif-condform" class="anchor"><i>closed RIF condition formula</i></span>, i.e., a RIF condition in which every variable, <tt>?V</tt>, is in the scope of a quantifier of the form <tt>Exists&nbsp;?V</tt>.  In addition, conformant BLD producers and consumers <i>should</i> preserve all annotations where possible.
</li></ul>
<ul><li> A <i><b>conformant RIF-BLD consumer</b></i> is a conformant BLD<sub>Τ,Ε</sub>
consumer in which Τ consists only of the symbol spaces and datatypes,
and Ε consists only of the external (function and predicate) schemas
that are required by RIF-BLD. The required symbol spaces are <tt>rif:iri</tt> and <tt>rif:local</tt>, and the required datatypes and externally defined schemas are those specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
A conformant RIF-BLD consumer must reject all inputs that do not match
the syntax of BLD. If it implements extensions, it may do so under user
control -- having a "strict BLD" mode and a "run-with-extensions" mode.
</li></ul>
<ul><li> A <i><b>conformant BLD producer</b></i> is a conformant BLD<sub>Τ,Ε</sub> producer, which produces documents that include only the datatypes and externals that are required by BLD.
</li></ul>
<div class="atRiskNote">
<p><strong id="atRisk3">Feature At Risk #3: Strictness Requirement</strong></p>
<p class="atRiskNoteHead">Note: This feature is <a href="http://www.w3.org/2005/10/Process-20051014/tr#cfi" class="external text" title="http://www.w3.org/2005/10/Process-20051014/tr#cfi">"at risk"</a> and may be removed from this specification based on feedback.   Please send feedback to <a href="mailto:public-rif-comments@w3.org" class="external text" title="mailto:public-rif-comments@w3.org">public-rif-comments@w3.org</a>.</p>
<p>The two preceding clauses are features <b>AT RISK</b>. In particular, the "strictness" requirement is under discussion.</p>
</div>
<p>RIF-BLD supports a wide variety of syntactic forms for terms and
formulas, which creates infrastructure for exchanging syntactically
diverse rule languages. It is important to realize, however, that the
above conformance statements make it possible for systems that do not
support some of the syntax directly to still support it through
syntactic transformations. For instance, disjunctions in rule premises
can be eliminated through a standard transformation, such as replacing <tt>p&nbsp;:- Or(q r)</tt> with a pair of rules <tt>p&nbsp;:- q, &nbsp; p&nbsp;:- r</tt>.
Terms with named arguments can be reduced to positional terms by
ordering the arguments by their names and incorporating the ordered
argument names into the predicate name. For instance, <tt>p(bb-&gt;1 aa-&gt;2)</tt> can be represented as <tt>p_aa_bb(2 1)</tt>.
</p><p><br>
<span id="sec-bld-fld-spec" class="anchor"></span>
</p>
<a name="RIF-BLD_as_a_Specialization_of_the_RIF_Framework_for_Logic_Dialects_.5BRIF-FLD.5D"></a><h2> <span class="mw-headline">6  RIF-BLD as a Specialization of the RIF Framework for Logic Dialects [<a href="#ref-rif-fld" title="">RIF-FLD</a>] </span></h2>
<p>This normative section describes RIF-BLD by specializing RIF-FLD. The reader is
assumed to be familiar with RIF-FLD as described in RIF framework for
logic dialects [<a href="#ref-rif-fld" title="">RIF-FLD</a>]. The reader who is not interested in how RIF-BLD is
derived from the framework can skip this section.
</p><p><br>
</p>
<a name="The_Presentation_Syntax_of_RIF-BLD_as_a_Specialization_of_RIF-FLD"></a><h4> <span class="mw-headline">6.1  The Presentation Syntax of RIF-BLD as a Specialization of RIF-FLD </span></h4>
<p>This section defines the precise relationship between the presentation syntax of RIF-BLD and the syntactic framework of RIF-FLD.
</p><p>The presentation syntax of the RIF Basic Logic Dialect is defined by specialization from the presentation syntax of the <a href="http://www.w3.org/2005/rules/wiki/FLD#sec-syntactic-framework" title="FLD">RIF Syntactic Framework for Logic Dialects</a> described in [<a href="#ref-rif-fld" title="">RIF-FLD</a>]. Section <a href="http://www.w3.org/2005/rules/wiki/FLD#sec-dialect-syntax" title="FLD">Syntax of a RIF Dialect as a Specialization of the RIF Framework</a> in [<a href="#ref-rif-fld" title="">RIF-FLD</a>] lists the parameters of the syntactic framework in mathematical English, which we will now specialize for RIF-BLD. 
</p>
<ol>
  <li>
      <i>Extension points</i>.
      <p>
          All extension points of RIF-FLD are removed (specialized by replacing them with zero objects).
      </p>
  </li>
  <li> <i>Alphabet</i>. 
    <p>
      The alphabet of the RIF-BLD presentation syntax is the alphabet of RIF-FLD with the symbols <tt>Dialect</tt>, <tt>Neg</tt>, and <tt>Naf</tt> excluded.
    </p>
  </li>
  <li> <i>Assignment of signatures to each constant and variable symbol</i>.
    <p>
      The signature set of RIF-BLD contains the following signatures:
    </p>
    <ol style="list-style-type: lower-alpha;">
      <li>Basic
	<ul>
	  <li><tt>individual{&nbsp;}</tt></li>
	  <li><tt>atomic{&nbsp;}</tt></li>
	</ul>
	<p>
	  The signature <tt>individual{&nbsp;}</tt> represents the context in which individual objects (but not atomic formulas) can appear.
	  <br>
	  The signature <tt>atomic{&nbsp;}</tt> represents the context where atomic formulas can occur. 
	</p>
      </li>
      <li>      
	 Signatures for lists
	 <ul>	 
	   <li>
	      The signature <tt>list</tt> for closed lists. It has the following arrow expressions: <tt>() ⇒ individual</tt>, <tt>(individual) ⇒ individual</tt>, <tt>(individual individual) ⇒ individual</tt>, ...
	   </li>
	   <li>	   
	      The signature <tt>openlist</tt> for open lists (that have tails). It has the following arrow expressions: <tt>(individual individual) ⇒ individual</tt>, <tt>(individual individual individual) ⇒ individual</tt>, ... 
	   </li>
	 </ul>
      </li>
      <li>Signatures for functions, predicates, and external functions and predicates
	<ul>
	  <li>
	    Function signature <tt>f</tt>. This signature has the arrow expressions for positional functions: <tt>() ⇒ individual</tt>, <tt>(individual) ⇒ individual</tt>, <tt>(individual individual) ⇒ individual</tt>, ..., plus the arrow expressions for functions with named arguments: <tt>(s1-&gt;individual ... sk-&gt;individual) ⇒ individual}</tt>, for all k&gt;0 and all <tt>s1, ..., sk</tt> ∈ <tt>ArgNames</tt>. 
	  </li>
	  <li>
	    Predicate signature <tt>p</tt>. This signature has the arrow expressions for positional predicates: <tt>() ⇒ atomic</tt>, <tt>(individual) ⇒ atomic</tt>, <tt>(individual individual) ⇒ atomic</tt>, ..., plus the arrow expressions for predicates with named arguments: <tt>(s1-&gt;individual ... sk-&gt;individual) ⇒ atomic}</tt>, for all k&gt;0 and all <tt>s1, ..., sk</tt> ∈ <tt>ArgNames</tt>.  
	  </li>
	  <li>
	    External function signature <tt>ef</tt>. This signature has the same arrow expressions as the signature <tt>f</tt>.
	  </li>
	  <li>
	    External predicate signature <tt>ep</tt>. This signature has the same arrow expressions as the signature <tt>p</tt>.
	  </li>
	</ul>
	<p>
	  In the RIF-BLD specialization of RIF-FLD, the argument names <tt>s1</tt>, ..., <tt>sk</tt> must be pairwise distinct.
	</p>
      </li>
      <li>Every symbol in <tt>Const</tt> has exactly one signature of the form: <tt>individual</tt>, <tt>f</tt>, <tt>p</tt>, <tt>ef</tt>, or <tt>ep</tt>.
	<p>
	  A constant cannot have the signature <tt>atomic</tt>, since only complex terms can have such signatures. Thus, by itself a symbol, <tt>p</tt>,  cannot be a proposition in RIF-BLD, but a term of the form <tt>p()</tt> can.
	</p>
	<p>
According to the above, each constant symbol in RIF-BLD can be either
an individual, a plain function, a plain predicate, an externally
defined function, or an externally defined predicate. However, the same
function symbol (plain or external) can occur with different numbers of
arguments in different places. Similarly, predicate symbols can occur
with different numbers of arguments. Note that such polyadic terms with
the same function or predicate symbol but different arities could be
replaced by terms with fixed arities: the arity information could be
encoded in the function or predicate names. For instance, the polyadic
predicate terms <tt>p(?X)</tt> and <tt>p(?X,?Y)</tt> could be represented, Prolog-style, as <tt>p/1(?X)</tt> and <tt>p/2(?X,?Y)</tt>, respectively, regarding the slash as part of the predicate names.
	</p>
      </li>
      <li>The constant symbols that correspond to RIF datatypes (XML Schema datatypes, <tt><a href="http://www.w3.org/2005/rules/wiki/DTB#rif-xmlliteral-space" title="DTB">rdf:XMLLiteral</a></tt>, <tt><a href="http://www.w3.org/2005/rules/wiki/DTB#rdf-PlainLiteral-space" title="DTB">rdf:PlainLiteral</a></tt>, etc.) all have the signature <tt>individual</tt> in RIF-BLD.
      </li>
      <li>The symbols of type <tt><a href="http://www.w3.org/2005/rules/wiki/DTB#rif-iri-space" title="DTB">rif:iri</a></tt> and <tt><a href="http://www.w3.org/2005/rules/wiki/DTB#rif-local-space" title="DTB">rif:local</a></tt> can have the following signatures in RIF-BLD: <tt>individual</tt>, <tt>f</tt>, <tt>p</tt>, <tt>ef</tt>, or <tt>ep</tt>.
      </li>
      <li>All variables are associated with signature <tt>individual</tt>, so they can range only over individuals.
      </li>
      <li>The signature for equality is <tt>={(individual&nbsp;individual)</tt> ⇒ <tt>atomic}</tt>.
	<p>
          This means that equality can compare only those terms whose signature is <tt>individual</tt>;
it cannot compare predicate or function symbols. Equality terms are
also not allowed to occur inside other terms, since the above signature
implies that any term of the form <tt>t = s</tt> has signature <tt>atomic</tt> and not <tt>individual</tt>.
	</p>
      </li>
      <li>The frame signature, <tt>-&gt;</tt>, is <tt>-&gt;{(individual&nbsp;individual&nbsp;individual)</tt> ⇒ <tt>atomic}</tt>.
	<p>
Note that this precludes the possibility that a frame term might occur
as an argument to a predicate, a function, or inside some other term. </p>
      </li>
      <li>The membership signature, <tt>#</tt>, is <tt>#{(individual&nbsp;individual) ⇒ atomic}</tt>.
	<p>
Note that this precludes the possibility that a membership term might
occur as an argument to a predicate, a function, or inside some other
term. </p>
      </li>
      <li>The signature for the subclass relationship is <tt>##{(individual&nbsp;individual)</tt> ⇒ <tt>atomic}</tt>.
	<p>
As with frames and membership terms, this precludes the possibility
that a subclass term might occur inside some other term. </p>
      </li>
    </ol>
    <p>
      RIF-BLD uses no special syntax for declaring signatures. Instead, the rule author specifies signatures <i>contextually</i>.
That is, since RIF-BLD requires that each symbol is associated with a
unique signature, the signature is determined from the context in which
the symbol is used. If a symbol is used in more than one context, the
parser must treat this as a syntax error. If no errors are found, all
terms and atomic formulas are guaranteed to be well-formed. Thus,
signatures are <i>not</i> part of the RIF-BLD language, and <tt>individual</tt> and <tt>atomic</tt> are not reserved keywords.
    </p>
  </li>
  <li><i>Supported types of terms</i>.
    <ul>
      <li>
	RIF-BLD supports the following types of terms defined by the syntactic framework (see the Section <a href="http://www.w3.org/2005/rules/wiki/FLD#sec-terms" title="FLD">Terms</a> of [<a href="#ref-rif-fld" title="">RIF-FLD</a>]):
	<ol style="list-style-type: lower-alpha;">
	  <li>constants</li>
	  <li>variables</li>
	  <li>positional</li>
	  <li>with named arguments</li>
	  <li>equality</li>
	  <li>frame</li>
	  <li>membership</li>
	  <li>subclass</li>
	  <li>external</li>
	</ol>
      </li>
      <li>Compared
to RIF-FLD, terms (both positional and with named arguments) have
significant restrictions in order to keep BLD relatively simple. <ul>
	  <li>The signature for the variable symbols does not permit
them to occur in the context of predicates, functions, or formulas. In
particular, in the RIF-BLD specialization of RIF-FLD, a variable is not
an atomic formula. </li>
	  <li>Likewise, a symbol cannot be an atomic formula by itself. That is, if <tt>p</tt> ∈ <tt>Const</tt> then <tt>p</tt> is not a well-formed atomic formula. However, <tt>p()</tt>
can be an atomic formula. Note that Propositional Logic can thus be
expressed in RIF-BLD using zero-argument predicate formulas.</li>
	  <li>Signatures
permit only constant symbols to occur in the context of functions or
predicate. Indeed, RIF-BLD signatures ensure that all variables have
the signature <tt>individual{&nbsp;}</tt> and all other terms, except for the constants from <tt>Const</tt>, can have either the signature <tt>individual{&nbsp;}</tt> or <tt>atomic{&nbsp;}</tt>. Therefore, if <tt>t</tt> is a (non-<tt>Const</tt>) term then <tt>t(...)</tt> is not a well-formed term.
	  </li>
	  <li>
            In an externally defined term, <tt>External(t)</tt>, <tt>t</tt> can be only a positional or a named-argument term. Compared to RIF-FLD, this restricts <tt>t</tt> so that it cannot be a constant, a frame, an equality, or a classification term. RIF-FLD's two-argument form of <tt>External</tt> is not supported in RIF-BLD either.
	    <p>
              Combined with the fact that in a well-formed term of the form <tt>External(t)</tt> the subterm <tt>t</tt> must be an instance of an external schema (by the <a href="http://www.w3.org/2005/rules/wiki/FLD#def-fld-well-formed-term" title="FLD">definition of well-formed external terms</a> in RIF-FLD), it follows that a predicate or a function symbol, <tt>p</tt>, that occurs in an external term <tt>External(p(...))</tt> cannot also occur as a non-external symbol.
	    </p>
	  </li>
	  <li>      
	    If a term, <tt>t</tt>, is an instance of an externally defined schema from <a href="http://www.w3.org/2005/rules/wiki/DTB#def-external-schema-set" title="DTB">the coherent set of external schemas associated with the language</a>, then <tt>t</tt> can occur only as <tt>External(t)</tt>, i.e., as an external term or atomic formula. 
	  </li>
	</ul>
      </li>
    </ul> 
  </li>
  <li>  
     No <a href="http://www.w3.org/2005/rules/wiki/FLD#ref-aggregate-term" title="FLD">aggregate terms</a>, <a href="http://www.w3.org/2005/rules/wiki/FLD#ref-module-term" title="FLD">module terms</a>, or <a href="http://www.w3.org/2005/rules/wiki/FLD#ref-fld-formula-term" title="FLD">formula terms</a> are allowed. (In RIF-FLD, formula terms correspond to compound formulas that involve logical connectives and quantifiers.)
  </li>
  <li><i>Required symbol spaces</i>.
    <p>RIF-BLD requires the symbol spaces defined in Section <a href="http://www.w3.org/2005/rules/wiki/DTB#sec-constants" title="DTB">Constants, Symbol Spaces, and Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
    </p>
  </li> 
  <li><i>Supported formulas</i>.
    <p>RIF-BLD supports the following types of formulas (see <a href="http://www.w3.org/2005/rules/wiki/FLD#sec-fld-wff" title="FLD">Well-formed Terms and Formulas</a> in [<a href="#ref-rif-fld" title="">RIF-FLD</a>] for the definitions): </p>
    <ul>
      <li><i><b>RIF-BLD condition</b></i>
	<p>
A RIF-BLD condition is an atomic formula, a conjunctive or disjunctive
combination of atomic formulas, or an external atomic formula. All
these can optionally have existential quantifiers. </p>
      </li>
      <li><i><b>RIF-BLD rule</b></i>
	<p>A RIF-BLD rule is a universally quantified RIF-FLD rule with the following restrictions: </p>
	<ul>
	  <li>The conclusion of the rule is an atomic formula or a conjunction of atomic formulas.
	    <div class="atRiskRef">
<p>Note: This feature (Equality in the rule conclusion) is <a href="http://www.w3.org/2005/10/Process-20051014/tr#cfi" class="external text" title="http://www.w3.org/2005/10/Process-20051014/tr#cfi">"at risk"</a>.   See <a href="#atRisk2" title="">feature at risk #2</a></p>
</div>
	  </li>
	  <li>      
	    None of the atomic formulas mentioned in the rule conclusion is externally defined (i.e., cannot have the form <tt>External(...)</tt>).
	  </li>
	  <li>The premise of the rule is a RIF-BLD condition. </li>
	  <li>All free (non-quantified) variables in the rule must be quantified with <tt>Forall</tt> outside of the rule (i.e., <tt>Forall&nbsp;?vars&nbsp;(conclusion&nbsp;:-&nbsp;premise)</tt>). </li>
	</ul>
      </li>
      <li>    
	<i><b>Universal fact</b></i>
	<p>
	  A universal fact is a universally quantified atomic formula with no free variables.
	</p>
      </li>
      <li>
	<i><b>RIF-BLD group</b></i>
	<p>
          A RIF-BLD group is a RIF-FLD group that contains only RIF-BLD rules,
	  universal facts, variable-free rule implications, variable-free atomic formulas, and RIF-BLD groups.
	</p>
      </li>
      <li>    
	<i><b>RIF-BLD document</b></i>
	<p>
          A RIF-BLD document is a RIF-FLD document that consists of directives and a RIF-BLD group formula. There is no <tt>Dialect</tt> or <tt>Module</tt> directives, and the <tt>Import(&lt;loc&gt;)</tt> directive (with one argument) can import RIF-BLD documents only. Here <tt>loc</tt> must be a Unicode character sequence that forms an IRI. There are no BLD-specific restrictions on the two-argument directive <tt>Import</tt> except that the second argument must be a Unicode sequence of characters of the form <tt>&lt;loc&gt;</tt>, where <tt>loc</tt> is an IRI.
	</p>
      </li>
    </ul>
  </li>
</ol>
<p>
  Negation (whether classical or default) is not allowed in RIF-BLD rules: neither in rule conclusions nor in premises.
</p>
<p><br>
</p><p><span id="sec-bld-specialization-semantics" class="anchor"></span>
</p>
<a name="The_Semantics_of_RIF-BLD_as_a_Specialization_of_RIF-FLD"></a><h4> <span class="mw-headline">6.2  The Semantics of RIF-BLD as a Specialization of RIF-FLD </span></h4>
<p>This normative section defines the precise relationship between the semantics
of RIF-BLD and the semantic framework of RIF-FLD. Specification of the
semantics that does not rely on RIF-FLD is given in Section <a href="#sec-bld-direct-semantics" title="">Direct Specification of RIF-BLD Semantics</a>.
</p><p>The semantics of the RIF Basic Logic Dialect is defined by specialization from the semantics of the <a href="http://www.w3.org/2005/rules/wiki/FLD#sec-fld-semantic-framework" title="FLD">semantic framework for logic dialects</a> of RIF. Section <a href="http://www.w3.org/2005/rules/wiki/FLD#sec-rif-dialect-semantics" title="FLD">Semantics of a RIF Dialect as a Specialization of the RIF Framework</a> in [<a href="#ref-rif-fld" title="">RIF-FLD</a>]
lists the parameters of the semantic framework that can be specialized.
Thus, for RIF-BLD, we need to look at the following parameters:
</p>
<ul>
  <li><i>The effect of the syntax</i>.
    <p> RIF-BLD does not
support negation. This is the only obvious simplification with respect
to RIF-FLD as far as the semantics is concerned. The restrictions on
the signatures of symbols in RIF-BLD do not affect the semantics in a
significant way. </p>
  </li>
  <li><i>Truth values</i>.
    <p>
      The set <i><b>TV</b></i> of truth values in RIF-BLD consists of two values, <b>t</b> and <b>f</b>, such that <b>f</b> &lt;<sub>t</sub> <b>t</b>. The order &lt;<sub>t</sub> is total. 
    </p>
  </li>
  <li><i>Datatypes</i>.
    <p>
      RIF-BLD supports the datatypes listed in Section <a href="http://www.w3.org/2005/rules/wiki/DTB#sec-data-types" title="DTB">Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
    </p>
  </li>
  <li><i>Logical entailment</i>.
    <p>
Recall that logical entailment in RIF-FLD is defined with respect to an
unspecified set of intended semantic structures and that dialects of
RIF must make this notion concrete. For RIF-BLD, this set is defined as
the set of all models. </p>
  </li>
  <li>
    <i>Import directive</i>.
    <p>
      The semantics of the two-argument <tt>Import</tt> directive is given in [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>]. The semantics of the one-argument directive is the same as in RIF-FLD.
    </p>
  </li>
</ul>
<p><span id="sec-bld-specialization-xml" class="anchor"></span>
</p>
<a name="The_XML_Serialization_of_RIF-BLD_as_a_Specialization_of_RIF-FLD"></a><h4> <span class="mw-headline">6.3  The XML Serialization of RIF-BLD as a Specialization of RIF-FLD </span></h4>
<p>Section <a href="http://www.w3.org/2005/rules/wiki/FLD#sec-translate-fld-to-xml" title="FLD">Mapping from the RIF-FLD
Presentation Syntax to the XML Syntax</a> of
[<a href="#ref-rif-fld" title="">RIF-FLD</a>]
defines a mapping, <tt>χ<sub>fld</sub></tt>, from the presentation syntax of
RIF-FLD to its XML serialization. When restricted to well-formed
RIF-BLD formulas, <tt>χ<sub>fld</sub></tt> coincides with the
<a href="#sec-translation" title="">BLD-to-XML mapping</a> <tt>χ<sub>bld</sub></tt>.
In this way, the XML serialization of RIF-BLD is a specialization of the
<a href="http://www.w3.org/2005/rules/wiki/FLD#sec-fld-specialization-framework" title="FLD">RIF-FLD XML Serialization Framework</a>
defined in [<a href="#ref-rif-fld" title="">RIF-FLD</a>].
</p><p><br>
</p>
<a name="RIF-BLD_Conformance_as_a_Specialization_of_RIF-FLD"></a><h4> <span class="mw-headline">6.4  RIF-BLD Conformance as a Specialization of RIF-FLD </span></h4>
<p>If T is a set of datatypes and symbol spaces and E a <a href="http://www.w3.org/2005/rules/wiki/DTB#def-external-schema-set" title="DTB">coherent set of external schemas</a> for functions and predicates, then the general definition of <a href="http://www.w3.org/2005/rules/wiki/FLD#sec-conformance" title="FLD">conformance in RIF-FLD</a> yields the notion of conformant BLD<sub>T,E</sub> producers and consumers.
</p><p>BLD further requires <i>strictness</i>, i.e., that a conformant
producer produces only the documents where T are precisely the
datatypes/symbol spaces and E are the external schemas specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], and that a conformant consumer consumes only such documents.
</p>
<div class="atRiskRef">
<p>Note: This feature (Strictness requirement) is <a href="http://www.w3.org/2005/10/Process-20051014/tr#cfi" class="external text" title="http://www.w3.org/2005/10/Process-20051014/tr#cfi">"at risk"</a>.   See <a href="#atRisk3" title="">feature at risk #3</a></p>
</div>
<a name="Acknowledgements"></a><h2> <span class="mw-headline">7  Acknowledgements </span></h2>
<p>This document is the product of the Rules Interchange Format (RIF)
Working Group (see below) whose members deserve recognition for their
time and commitment. The editors extend special thanks to:
Jos de Bruijn, Gary Hallmark, Stella Mitchell, Leora Morgenstern,
Adrian Paschke, Axel Polleres, and Dave Reynolds, for their thorough
reviews and insightful discussions; the working group chairs, Chris
Welty and Christian de Sainte-Marie, for their invaluable technical
help and inspirational leadership; and W3C staff contact Sandro Hawke,
a constant source of ideas, help, and feedback.
</p><p><br>The regular attendees at meetings of the Rule Interchange
Format (RIF) Working Group at the time of the publication were:
Adrian Paschke (Freie Universitaet Berlin), Axel Polleres (DERI),
Changhai Ke (ILOG),
Chris Welty (IBM), Christian de Sainte Marie (ILOG), Dave Reynolds
(HP), Gary Hallmark (ORACLE), Harold Boley (NRC), Hassan Aït-Kaci
(ILOG), Jos de Bruijn (FUB),
Leora Morgenstern (IBM), Michael Kifer (Stony Brook), Mike Dean (BBN),
Sandro Hawke (W3C/MIT), and
Stella Mitchell (IBM).
We would also like to thank past members of the working group, Allen
Ginsberg, David Hirtle, Igor Mozetic, and Paula-Lavinia Patranjan.
</p>
<a name="References"></a><h2> <span class="mw-headline">8  References </span></h2>
<a name="Normative_References"></a><h3> <span class="mw-headline">8.1  Normative References </span></h3>
<p><span id="ref-rdf-concepts" class="anchor"></span> 
</p>
<dl><dt> [RDF-CONCEPTS]
</dt><dd> <i>Resource Description Framework (RDF): Concepts and Abstract Syntax</i>, Klyne G., Carroll J. (Editors), W3C Recommendation, 10 February 2004, <a href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" class="external free" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/</a>. Latest version available at <a href="http://www.w3.org/TR/rdf-concepts/" class="external free" title="http://www.w3.org/TR/rdf-concepts/">http://www.w3.org/TR/rdf-concepts/</a>. 
</dd></dl>
<p><span id="ref-rfc-3066" class="anchor"></span> 
</p>
<dl><dt> [RFC-3066]
</dt><dd> <i><a href="http://tools.ietf.org/html/rfc3066" class="external" title="http://tools.ietf.org/html/rfc3066">RFC 3066</a> - Tags for the Identification of Languages</i>, H. Alvestrand, IETF, January 2001. This document is <a href="http://www.isi.edu/in-notes/rfc3066.txt" class="external free" title="http://www.isi.edu/in-notes/rfc3066.txt">http://www.isi.edu/in-notes/rfc3066.txt</a>. 
</dd></dl>
<p><span id="ref-rfc-3987" class="anchor"></span> 
</p>
<dl><dt> [RFC-3987]
</dt><dd> <i><a href="http://tools.ietf.org/html/rfc3987" class="external" title="http://tools.ietf.org/html/rfc3987">RFC 3987</a> - Internationalized Resource Identifiers (IRIs)</i>, M. Duerst and M. Suignard, IETF, January 2005. This document is <a href="http://www.ietf.org/rfc/rfc3987.txt" class="external free" title="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.
</dd></dl>
<p><span id="ref-rif-core" class="anchor"></span> 
</p>
<dl><dt> [RIF-Core]
</dt><dd> <i>RIF Core Dialect</i>, Harold Boley, Gary Hallmark, Michael
Kifer, Adrian Paschke, Axel Polleres and Dave Reynolds (Editors), W3C
Rule Interchange Format Working Group Draft. Latest Version available
at <a href="http://www.w3.org/2005/rules/wiki/Core" class="external free" title="http://www.w3.org/2005/rules/wiki/Core">http://www.w3.org/2005/rules/wiki/Core</a>.
</dd></dl>
<p><span id="ref-rif-dtb" class="anchor"></span>
</p>
<dl><dt> [RIF-DTB]
</dt><dd> <i>RIF Datatypes and Built-Ins 1.0</i>, Polleres A., Boley H. and Kifer M. (Editors), W3C Rule Interchange Format Working Group Draft. Latest Version available at <a href="http://www.w3.org/2005/rules/wiki/DTB" class="external free" title="http://www.w3.org/2005/rules/wiki/DTB">http://www.w3.org/2005/rules/wiki/DTB</a>.
</dd></dl>
<p><span id="ref-rif-fld" class="anchor"></span>
</p>
<dl><dt> [RIF-FLD]
</dt><dd> <i>RIF Framework for Logic Dialects</i>, Boley H. and Kifer M. (Editors), W3C Rule Interchange Format Working Group Draft. Latest Version available at <a href="http://www.w3.org/2005/rules/wiki/FLD" class="external free" title="http://www.w3.org/2005/rules/wiki/FLD">http://www.w3.org/2005/rules/wiki/FLD</a>.
</dd></dl>
<p><span id="ref-rif-prd" class="anchor"></span>
</p>
<dl><dt> [RIF-PRD]
</dt><dd> <i>RIF Production Rule Dialect</i>, de Sainte Marie C.,
Paschke A., and Hallmark G. (Editors), W3C Rule Interchange Format
Working Group Draft. Latest Version available at <a href="http://www.w3.org/2005/rules/wiki/PRD" class="external free" title="http://www.w3.org/2005/rules/wiki/PRD">http://www.w3.org/2005/rules/wiki/PRD</a>.
</dd></dl>
<p><span id="ref-rif-swc" class="anchor"></span>
</p>
<dl><dt> [RIF-RDF+OWL]
</dt><dd> <i>RIF RDF and OWL Compatibility</i>, de Bruijn, J. (Editor), W3C Rule Interchange Format Working Group Draft. Latest Version available at <a href="http://www.w3.org/2005/rules/wiki/SWC" class="external free" title="http://www.w3.org/2005/rules/wiki/SWC">http://www.w3.org/2005/rules/wiki/SWC</a>.
</dd></dl>
<p><span id="ref-xml-1-point-0" class="anchor"></span> 
</p>
<dl><dt> [XML1.0]
</dt><dd> <i>Extensible Markup Language (XML) 1.0 (Fourth Edition)</i>, W3C Recommendation, World Wide Web Consortium, 16 August 2006, edited in place 29 September 2006. This version is <a href="http://www.w3.org/TR/2006/REC-xml-20060816/" class="external free" title="http://www.w3.org/TR/2006/REC-xml-20060816/">http://www.w3.org/TR/2006/REC-xml-20060816/</a>.
</dd></dl>
<p><span id="ref-xml-base" class="anchor"></span> 
</p>
<dl><dt> [XML-Base]
</dt><dd> <i>XML Base</i>, W3C Recommendation, World Wide Web Consortium, 27 June 2001. This version is <a href="http://www.w3.org/TR/2001/REC-xmlbase-20010627/" class="external free" title="http://www.w3.org/TR/2001/REC-xmlbase-20010627/">http://www.w3.org/TR/2001/REC-xmlbase-20010627/</a>. The latest version is available at <a href="http://www.w3.org/TR/xmlbase/" class="external free" title="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</a>.
</dd></dl>
<p>
</p>
<dl><dt> <span id="ref-xml-schema2">[XML Schema Datatypes]</span>
</dt><dd> <cite><a href="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/" class="external text" title="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</a></cite>.
David Peterson, Shudi Gao, Ashok Malhotra, C. M. Sperberg-McQueen, and
Henry S. Thompson, eds. W3C Candidate Recommendation, 30 April 2009,
http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/. Latest version
available as http://www.w3.org/TR/xmlschema11-2/.
</dd></dl>
<a name="Informational_References"></a><h3> <span class="mw-headline">8.2  Informational References </span></h3>
<p><span id="ref-alternating-normal-form" class="anchor"></span> 
</p>
<dl><dt> [ANF01]
</dt><dd> <i>Normal Form Conventions for XML Representations of Structured Data</i>, Henry S. Thompson. October 2001. Available at <a href="http://www.ltg.ed.ac.uk/%7Eht/normalForms.html" class="external free" title="http://www.ltg.ed.ac.uk/~ht/normalForms.html">http://www.ltg.ed.ac.uk/~ht/normalForms.html</a>.
</dd></dl>
<p><span id="ref-sparql-expr" class="anchor"></span>
</p>
<dl><dt> [AG08]
</dt><dd> The Expressive Power of SPARQL, Renzo Angles and Claudio Gutierrez. <i>International Semantic Web Conference 2008</i>: 114-129
</dd></dl>
<p><span id="ref-sparql-rules" class="anchor"></span>
</p>
<dl><dt> [AP07]
</dt><dd> From SPARQL to rules (and back), Axel Polleres. <i>WWW 2007</i>: 787-796 
</dd></dl>
<p><span id="ref-cg" class="anchor"></span> 
</p>
<dl><dt> [CG]
</dt><dd> Information Processing, John Sowa, in <i>Mind and Machine.</i> JReading, MA: Addison-Wesley Publ., 1984.
</dd></dl>
<p><span id="ref-chang-lee" class="anchor"></span> 
</p>
<dl><dt> [CL73]
</dt><dd> <i>Symbolic Logic and Mechanical Theorem Proving</i>, C.L. Chang and R.C.T. Lee. Academic Press, 1973.
</dd></dl>
<p><span id="ref-common-logic" class="anchor"></span> 
</p>
<dl><dt> [CL07]
</dt><dd> <i>ISO/IEC 24707:2007</i>.  The ISO Common Logic Standard.  Available through <a href="http://common-logic.org/" class="external free" title="http://common-logic.org">http://common-logic.org</a>
</dd></dl>
<p><span id="ref-curie" class="anchor"></span> 
</p>
<dl><dt> [CURIE]
</dt><dd> <i>CURIE Syntax 1.0: A syntax for expressing Compact URIs</i>, Mark Birbeck, Shane McCarron.  W3C Working Draft 2 April 2008. Available at <a href="http://www.w3.org/TR/curie/" class="external free" title="http://www.w3.org/TR/curie/">http://www.w3.org/TR/curie/</a>.
</dd></dl>
<p><span id="ref-enderton01" class="anchor"></span> 
</p>
<dl><dt> [Enderton01]
</dt><dd> <i>A Mathematical Introduction to Logic, Second Edition</i>, H. B. Enderton. Academic Press, 2001.
</dd></dl>
<p><span id="ref-kif" class="anchor"></span> 
</p>
<dl><dt> [KIF]
</dt><dd> <i>Knowledge Interchange Format,</i> M. Genesereth, et al. 1998.  Available at <a href="http://logic.stanford.edu/kif/dpans.html" class="external free" title="http://logic.stanford.edu/kif/dpans.html">http://logic.stanford.edu/kif/dpans.html</a>
</dd></dl>
<p><span id="ref-flogic-95" class="anchor"></span> 
</p>
<dl><dt> [KLW95]
</dt><dd> <i>Logical foundations of object-oriented and frame-based languages,</i> M. Kifer, G. Lausen, J. Wu. Journal of ACM, July 1995, pp. 741--843.
</dd></dl>
<p><span id="ref-mendelson97" class="anchor"></span> 
</p>
<dl><dt> [Mendelson97]
</dt><dd> <i>Introduction to Mathematical Logic, Fourth Edition</i>, E. Mendelson. Chapman &amp; Hall, 1997.
</dd></dl>
<dl><dt><span id="ref-owl-reference">[OWL-Reference]</span>
</dt><dd> <i><a href="http://www.w3.org/TR/2004/REC-owl-ref-20040210/" class="external text" title="http://www.w3.org/TR/2004/REC-owl-ref-20040210/">OWL Web Ontology Language Reference</a></i>, M. Dean, G. Schreiber, Editors, W3C Recommendation, 10 February 2004. Latest version available at <a href="http://www.w3.org/TR/owl-ref/" class="external free" title="http://www.w3.org/TR/owl-ref/">http://www.w3.org/TR/owl-ref/</a>.
</dd></dl>
<p><span id="ref-rdf-syntax" class="anchor"></span> 
</p>
<dl><dt> [RDFSYN04]
</dt><dd> <i>RDF/XML Syntax Specification (Revised)</i>, Dave Beckett, Editor, W3C Recommendation, 10 February 2004, <a href="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/" class="external free" title="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/">http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/</a>. Latest version available at <a href="http://www.w3.org/TR/rdf-syntax-grammar/" class="external free" title="http://www.w3.org/TR/rdf-syntax-grammar/">http://www.w3.org/TR/rdf-syntax-grammar/</a>.
</dd></dl>
<p><span id="ref-rif-ucr" class="anchor"></span>
</p>
<dl><dt> [RIF-UCR]
</dt><dd> <i>RIF Use Cases and Requirements</i>, Paschke A., Hirtle D.,
Ginsberg A., Patranjan P-L., McCabe F. (Editors), W3C Rule Interchange
Format Working Group Draft. Latest Version available at <a href="http://www.w3.org/2005/rules/wiki/UCR" class="external free" title="http://www.w3.org/2005/rules/wiki/UCR">http://www.w3.org/2005/rules/wiki/UCR</a>.
</dd></dl>
<p><span id="ref-steele90" class="anchor"></span> 
</p>
<dl><dt> [Steele90]
</dt><dd> <i>Common LISP: The Language, Second Edition</i>, G. L. Steele Jr. Digital Press, 1990.
</dd></dl>
<p><span id="ref-type-and-role-tags" class="anchor"></span> 
</p>
<dl><dt> [TRT03]
</dt><dd> <i>Object-Oriented RuleML: User-Level Roles, URI-Grounded Clauses, and Order-Sorted Terms</i>, H. Boley.  Springer LNCS 2876, Oct. 2003, pp. 1-16. Preprint at <a href="http://iit-iti.nrc-cnrc.gc.ca/publications/nrc-46502_e.html" class="external free" title="http://iit-iti.nrc-cnrc.gc.ca/publications/nrc-46502_e.html">http://iit-iti.nrc-cnrc.gc.ca/publications/nrc-46502_e.html</a>.
</dd></dl>
<p><span id="ref-rif-urd" class="anchor"></span> 
</p>
<dl><dt> [URD08]
</dt><dd> <i>Uncertainty Treatment in the Rule Interchange Format: From Encoding to Extension</i>, J. Zhao, H. Boley.  4th Int’l Workshop on Uncertainty Reasoning for the Semantic Web (URSW 2008). Available at <a href="http://c4i.gmu.edu/ursw/2008/papers/URSW2008_F9_ZhaoBoley.pdf" class="external free" title="http://c4i.gmu.edu/ursw/2008/papers/URSW2008_F9_ZhaoBoley.pdf">http://c4i.gmu.edu/ursw/2008/papers/URSW2008_F9_ZhaoBoley.pdf</a>.
</dd></dl>
<p><span id="ref-vanemden-kowalski" class="anchor"></span> 
</p>
<dl><dt> [vEK76]
</dt><dd> <i>The semantics of predicate logic as a programming language</i>, M. van Emden and R. Kowalski. Journal of the ACM 23 (1976), pp. 733-742.
</dd></dl>
<p><br>
</p><p><span id="sec-xsd-bld" class="anchor"></span>
</p>
<a name="Appendix:_XML_Schema_for_RIF-BLD"></a><h2> <span class="mw-headline">9  Appendix: XML Schema for RIF-BLD </span></h2>
<p>The <b>namespace</b> of RIF is <i>http://www.w3.org/2007/rif#</i>. 
</p><p>XML schemas for the RIF-BLD sublanguages are defined below and are also available <a href="http://www.ruleml.org/rif/bld/LC/" class="external text" title="http://www.ruleml.org/rif/bld/LC/">here</a> with additional examples. 
</p><p><br>
</p>
<a name="Condition_Language"></a><h3> <span class="mw-headline">9.1  Condition Language </span></h3>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 
 &lt;xs:schema 
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:xml="http://www.w3.org/XML/1998/namespace"
  xmlns="http://www.w3.org/2007/rif#"
  targetNamespace="http://www.w3.org/2007/rif#"
  elementFormDefault="qualified"
  version="Id: BLDCond.xsd, v. 1.4, 2009-06-25, dhirtle/hboley"&gt;

 &lt;xs:import namespace='http://www.w3.org/XML/1998/namespace'
            schemaLocation='http://www.w3.org/2001/xml.xsd'/&gt; 
 
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
    This is the XML schema for the Condition Language as defined by
    the Last Call Draft of the RIF Basic Logic Dialect.
    
    The schema is based on the following EBNF for the RIF-BLD Condition Language:
 
  FORMULA       &nbsp;::= IRIMETA? 'And' '(' FORMULA* ')' |
                     IRIMETA? 'Or' '(' FORMULA* ')' |
                     IRIMETA? 'Exists' Var+ '(' FORMULA ')' |
                     ATOMIC |
                     IRIMETA? 'External' '(' Atom ')'
  ATOMIC        &nbsp;::= IRIMETA? (Atom | Equal | Member | Subclass | Frame)
  Atom          &nbsp;::= UNITERM
  UNITERM       &nbsp;::= Const '(' (TERM* | (Name '-&gt;' TERM)*) ')'
  Equal         &nbsp;::= TERM '=' TERM
  Member        &nbsp;::= TERM '#' TERM
  Subclass      &nbsp;::= TERM '##' TERM
  Frame         &nbsp;::= TERM '[' (TERM '-&gt;' TERM)* ']'
  TERM          &nbsp;::= IRIMETA? (Const | Var | Expr | List | 'External' '(' Expr ')')
  Expr          &nbsp;::= UNITERM
  List          &nbsp;::= 'List' '(' TERM* ')' | 'List' '(' TERM+ '|' TERM ')'
  Const         &nbsp;::= '"' UNICODESTRING '"^^' SYMSPACE | CONSTSHORT
  Name          &nbsp;::= UNICODESTRING
  Var           &nbsp;::= '?' UNICODESTRING
  SYMSPACE      &nbsp;::= ANGLEBRACKIRI | CURIE
 
  IRIMETA       &nbsp;::= '(*' IRICONST? (Frame | 'And' '(' Frame* ')')? '*)'
 
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  
  &lt;xs:group name="FORMULA"&gt;  
    &lt;!--
  FORMULA       &nbsp;::= IRIMETA? 'And' '(' FORMULA* ')' |
                     IRIMETA? 'Or' '(' FORMULA* ')' |
                     IRIMETA? 'Exists' Var+ '(' FORMULA ')' |
                     ATOMIC |
                     IRIMETA? 'External' '(' Atom ')'
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="And"/&gt;
      &lt;xs:element ref="Or"/&gt;
      &lt;xs:element ref="Exists"/&gt;
      &lt;xs:group ref="ATOMIC"/&gt;
      &lt;xs:element name="External" type="External-FORMULA.type"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
  
  &lt;xs:complexType name="External-FORMULA.type"&gt;
    &lt;!-- sensitive to FORMULA (Atom) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="content" type="content-FORMULA.type"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="content-FORMULA.type"&gt;
    &lt;!-- sensitive to FORMULA (Atom) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Atom"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:element name="And"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="formula" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Or"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="formula" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Exists"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="declare" minOccurs="1" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="formula"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="formula"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="FORMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="declare"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Var"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:group name="ATOMIC"&gt;
    &lt;!--
  ATOMIC        &nbsp;::= IRIMETA? (Atom | Equal | Member | Subclass | Frame)
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="Atom"/&gt;
      &lt;xs:element ref="Equal"/&gt;
      &lt;xs:element ref="Member"/&gt;
      &lt;xs:element ref="Subclass"/&gt;
      &lt;xs:element ref="Frame"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
  
  &lt;xs:element name="Atom"&gt;
    &lt;!--
  Atom          &nbsp;::= UNITERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="UNITERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;  
  
  &lt;xs:group name="UNITERM"&gt;
    &lt;!--
  UNITERM       &nbsp;::= Const '(' (TERM* | (Name '-&gt;' TERM)*) ')'
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="op"/&gt;
      &lt;xs:choice&gt;
        &lt;xs:element ref="args" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element name="slot" type="slot-UNITERM.type" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:element name="op"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Const"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="args"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM" minOccurs="1" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:complexType name="slot-UNITERM.type"&gt;
    &lt;!-- sensitive to UNITERM (Name) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Name"/&gt;
      &lt;xs:group ref="TERM"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:element name="Equal"&gt;
    &lt;!--
  Equal         &nbsp;::= TERM '=' TERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="left"/&gt;
        &lt;xs:element ref="right"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="left"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="right"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Member"&gt;
    &lt;!--
  Member        &nbsp;::= TERM '#' TERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="instance"/&gt;
        &lt;xs:element ref="class"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Subclass"&gt;
    &lt;!--
  Subclass      &nbsp;::= TERM '##' TERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="sub"/&gt;
        &lt;xs:element ref="super"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="instance"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="class"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="sub"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="super"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
    
  &lt;xs:element name="Frame"&gt;
    &lt;!--
  Frame         &nbsp;::= TERM '[' (TERM '-&gt;' TERM)* ']'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="object"/&gt;
        &lt;xs:element name="slot" type="slot-Frame.type" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="object"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:complexType name="slot-Frame.type"&gt;
    &lt;!-- sensitive to Frame (TERM) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="TERM"/&gt;
      &lt;xs:group ref="TERM"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:group name="TERM"&gt;  
    &lt;!--
  TERM          &nbsp;::= IRIMETA? (Const | Var | Expr | List | 'External' '(' Expr ')')
    --&gt;
      &lt;xs:choice&gt;
         &lt;xs:element ref="Const"/&gt;
         &lt;xs:element ref="Var"/&gt;
         &lt;xs:element ref="Expr"/&gt;
         &lt;xs:element ref="List"/&gt;
         &lt;xs:element name="External" type="External-TERM.type"/&gt;
      &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:element name="List"&gt;  
    &lt;!--
  List          &nbsp;::= 'List' '(' TERM* ')' | 'List' '(' TERM+ '|' TERM ')'
             rewritten as
  List          &nbsp;::= 'List' '(' LISTELEMENTS? ')'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="LISTELEMENTS" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:group name="LISTELEMENTS"&gt;
    &lt;!--
  LISTELEMENTS  &nbsp;::= TERM+ ('|' TERM)?
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="TERM" minOccurs="1" maxOccurs="unbounded"/&gt;
      &lt;xs:element ref="rest" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;

  &lt;xs:element name="rest"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:complexType name="External-TERM.type"&gt;
    &lt;!-- sensitive to TERM (Expr) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="content" type="content-TERM.type"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="content-TERM.type"&gt;
    &lt;!-- sensitive to TERM (Expr) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Expr"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:element name="Expr"&gt;
    &lt;!--
  Expr          &nbsp;::= UNITERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="UNITERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Const"&gt;
    &lt;!--
  Const         &nbsp;::= '"' UNICODESTRING '"^^' SYMSPACE | CONSTSHORT
    --&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="type" type="xs:anyURI" use="required"/&gt; 
      &lt;xs:attribute ref="xml:lang"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Name" type="xs:string"&gt;
    &lt;!--
  Name          &nbsp;::= UNICODESTRING
    --&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Var"&gt;
    &lt;!--
  Var           &nbsp;::= '?' UNICODESTRING
    --&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:group name="IRIMETA"&gt;
    &lt;!--
  IRIMETA  &nbsp;::= '(*' IRICONST? (Frame | 'And' '(' Frame* ')')? '*)'
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="id" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="meta" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:element name="id"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="Const" type="IRICONST.type"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="meta"&gt;
    &lt;xs:complexType&gt;
     &lt;xs:choice&gt;
       &lt;xs:element ref="Frame"/&gt;
       &lt;xs:element name="And" type="And-meta.type"/&gt;
     &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:complexType name="And-meta.type"&gt;
  &lt;!-- sensitive to meta (Frame) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="formula" type="formula-meta.type" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="formula-meta.type"&gt;
    &lt;!-- sensitive to meta (Frame) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Frame"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="IRICONST.type" mixed="true"&gt;
    &lt;!-- sensitive to location/id context--&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute name="type" type="xs:anyURI" use="required" fixed="http://www.w3.org/2007/rif#iri"/&gt;
  &lt;/xs:complexType&gt;
  
 &lt;/xs:schema&gt;
</pre>
<a name="Rule_Language"></a><h3> <span class="mw-headline">9.2  Rule Language </span></h3>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 
 &lt;xs:schema 
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:xml="http://www.w3.org/XML/1998/namespace"
  xmlns="http://www.w3.org/2007/rif#"
  targetNamespace="http://www.w3.org/2007/rif#"
  elementFormDefault="qualified"
  version="Id: BLDRule.xsd, v. 1.5, 2009-07-03, dhirtle/hboley"&gt;
 
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
    This is the XML schema for the Rule Language as defined by
    the Last Call Draft of the RIF Basic Logic Dialect.
    
    The schema is based on the following EBNF for the RIF-BLD Rule Language:
  
  Document &nbsp;::= IRIMETA? 'Document' '(' Base? Prefix* Import* Group? ')'
  Base     &nbsp;::= 'Base' '(' ANGLEBRACKIRI ')'
  Prefix   &nbsp;::= 'Prefix' '(' Name ANGLEBRACKIRI ')'
  Import   &nbsp;::= IRIMETA? 'Import' '(' LOCATOR PROFILE? ')'
  Group    &nbsp;::= IRIMETA? 'Group' '(' (RULE | Group)* ')'
  RULE     &nbsp;::= (IRIMETA? 'Forall' Var+ '(' CLAUSE ')') | CLAUSE
  CLAUSE   &nbsp;::= Implies | ATOMIC
  Implies  &nbsp;::= IRIMETA? (ATOMIC | 'And' '(' ATOMIC* ')') ':-' FORMULA
  LOCATOR  &nbsp;::= ANGLEBRACKIRI
  PROFILE  &nbsp;::= ANGLEBRACKIRI
      
    Note that this is an extension of the syntax for the RIF-BLD Condition Language (BLDCond.xsd).
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
 
  &lt;!-- The Rule Language includes the Condition Language from the same directory --&gt;
  &lt;xs:include schemaLocation="BLDCond.xsd"/&gt;
 
  &lt;xs:element name="Document"&gt;
    &lt;!--
  Document &nbsp;::= IRIMETA? 'Document' '(' Base? Prefix* Import* Group? ')'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="directive" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="payload" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="directive"&gt;
    &lt;!--
  Base and Prefix represented directly in XML
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Import"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="payload"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Group"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Import"&gt;
    &lt;!--
  Import   &nbsp;::= IRIMETA? 'Import' '(' LOCATOR PROFILE? ')'
  LOCATOR  &nbsp;::= ANGLEBRACKIRI
  PROFILE  &nbsp;::= ANGLEBRACKIRI
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt; 
        &lt;xs:element ref="location"/&gt;
        &lt;xs:element ref="profile" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="location"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="Const" type="ANYURICONST.type"/&gt;   &lt;!-- type="&amp;xs;anyURI" --&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="profile"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="Const" type="ANYURICONST.type"/&gt;   &lt;!-- type="&amp;xs;anyURI" --&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Group"&gt;
    &lt;!--
  Group    &nbsp;::= IRIMETA? 'Group' '(' (RULE | Group)* ')'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="sentence" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="sentence"&gt;
   &lt;xs:complexType&gt;
     &lt;xs:choice&gt;
       &lt;xs:group ref="RULE"/&gt;
       &lt;xs:element ref="Group"/&gt;
     &lt;/xs:choice&gt;
   &lt;/xs:complexType&gt;
 &lt;/xs:element&gt;
  
  &lt;xs:group name="RULE"&gt;
    &lt;!--
  RULE     &nbsp;::= (IRIMETA? 'Forall' Var+ '(' CLAUSE ')') | CLAUSE
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="Forall"/&gt;
      &lt;xs:group ref="CLAUSE"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:element name="Forall"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="declare" minOccurs="1" maxOccurs="unbounded"/&gt;
        &lt;!-- different from formula in And, Or and Exists --&gt;
        &lt;xs:element name="formula"&gt;
          &lt;xs:complexType&gt;
            &lt;xs:group ref="CLAUSE"/&gt;
          &lt;/xs:complexType&gt;
        &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:group name="CLAUSE"&gt;  
    &lt;!--
  CLAUSE  &nbsp;::= Implies | ATOMIC
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="Implies"/&gt;
      &lt;xs:group ref="ATOMIC"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
  
  &lt;xs:element name="Implies"&gt;
    &lt;!--
  Implies  &nbsp;::= IRIMETA? (ATOMIC | 'And' '(' ATOMIC* ')') ':-' FORMULA
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="if"/&gt;
        &lt;xs:element ref="then"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="if"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="FORMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="then"&gt;
    &lt;xs:complexType&gt;
     &lt;xs:choice&gt;
       &lt;xs:group ref="ATOMIC"/&gt;
       &lt;xs:element name="And" type="And-then.type"/&gt;
     &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:complexType name="And-then.type"&gt;
    &lt;!-- sensitive to then (ATOMIC) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="formula" type="formula-then.type" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="formula-then.type"&gt;
    &lt;!-- sensitive to then (ATOMIC) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="ATOMIC"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="ANYURICONST.type" mixed="true"&gt;
    &lt;!-- sensitive to location/profile context--&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute name="type" type="xs:anyURI" use="required" fixed="http://www.w3.org/2001/XMLSchema#anyURI"/&gt;
  &lt;/xs:complexType&gt;
   
 &lt;/xs:schema&gt;
</pre>
<p><br>
</p><p><span id="sec-changelog" class="anchor"></span>
</p>
<a name="Appendix:_Changes_Since_the_Last_Call_Version_.282008-07-30.29"></a><h2> <span class="mw-headline">10  Appendix: Changes Since the Last Call Version (2008-07-30) </span></h2>
<p>This section summarizes the main changes to this document since the <a href="http://www.w3.org/TR/2008/WD-rif-bld-20080730/" class="external text" title="http://www.w3.org/TR/2008/WD-rif-bld-20080730/">"last call" public snapshot of July 30, 2008</a>.
</p>
<ul><li> The definition of entailment in Section <a href="#sec-logical-entailment" title="">Logical Entailment</a> relied on the notion of a "query document," which was not defined. The definitions in Sections <a href="#sec-interpretation-of-documents" title="">Interpretation of Documents</a> and <a href="#sec-logical-entailment" title="">Logical Entailment</a> has been changed to eliminate this and related problems.
</li><li> Section <a href="#sec-concrete-syntax" title="">EBNF Grammar for the Presentation Syntax of RIF-BLD</a>
now presents the EBNF of the entire language in one place. Previously
the EBNF was given forst for the condition sublanguage and then
repeated again when the entire rule language is defined.
</li><li> Symbols can now have many different arities.
</li><li> Lists have been added.
</li><li> Import: the first argument is now a character sequence that forms and IRI.
</li><li> Base, Prefix, Import: IRIs are now delimited with angle brackets.
</li><li> Numerous clarifications and explanations were added in response to the public comments.
</li><li> A number of typos were found and fixed.
</li></ul>
<p><br>
</p>
</div>

<!-- 
NewPP limit report
Preprocessor node count: 2660/1000000
Post-expand include size: 2388/2097152 bytes
Template argument size: 287/2097152 bytes
-->
<div class="printfooter">
Retrieved from "<a href="http://www.w3.org/2005/rules/wiki/BLD">http://www.w3.org/2005/rules/wiki/BLD</a>"</div>
						<!-- end content -->
			<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
					 <li id="ca-nstab-main" class="selected"><a href="http://www.w3.org/2005/rules/wiki/BLD" title="View the content page [alt-c]" accesskey="c">Page</a></li>
					 <li id="ca-talk" class="new"><a href="http://www.w3.org/2005/rules/wiki/index.php?title=Talk:BLD&amp;action=edit" title="Discussion about the content page [alt-t]" accesskey="t">Discussion</a></li>
					 <li id="ca-viewsource"><a href="http://www.w3.org/2005/rules/wiki/index.php?title=BLD&amp;action=edit" title="This page is protected. You can view its source. [alt-e]" accesskey="e">View source</a></li>
					 <li id="ca-history"><a href="http://www.w3.org/2005/rules/wiki/index.php?title=BLD&amp;action=history" title="Past versions of this page. [alt-h]" accesskey="h">History</a></li>
				</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="http://www.w3.org/2005/rules/wiki/index.php?title=Special:Userlogin&amp;returnto=BLD" title="You are encouraged to log in, it is not mandatory however. [alt-o]" accesskey="o">Log in / create account</a></li>
				<li id="pt-openidlogin"><a href="http://www.w3.org/2005/rules/wiki/index.php?title=Special:OpenIDLogin&amp;returnto=BLD">Login with OpenID</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://www.w3.org/Icons/w3c_home);" href="http://www.w3.org/2005/rules/wiki/RIF_Working_Group" title="Visit the Main Page [alt-z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class="portlet" id="p-RIF_Working_Group">
		<h5>RIF Working Group</h5>
		<div class="pBody">
			<ul>
				<li id="n-Home"><a href="http://www.w3.org/2005/rules/wiki/RIF_Working_Group">Home</a></li>
				<li id="n-Events"><a href="http://www.w3.org/2005/rules/wiki/RIF:Current_events">Events</a></li>
				<li id="n-Meetings"><a href="http://www.w3.org/2005/rules/wiki/Meetings">Meetings</a></li>
				<li id="n-Mail-Archives"><a href="http://lists.w3.org/Archives/Public/public-rif-wg">Mail Archives</a></li>
				<li id="n-Blog"><a href="http://www.w3.org/blog/SW?cat=41">Blog</a></li>
				<li id="n-Tracker"><a href="http://www.w3.org/2005/rules/wg/track">Tracker</a></li>
				<li id="n-Resolutions"><a href="http://www.w3.org/2005/rules/wiki/Resolutions">Resolutions</a></li>
				<li id="n-Charter"><a href="http://www.w3.org/2005/rules/wg/charter.html">Charter</a></li>
				<li id="n-Old-Wiki"><a href="http://www.w3.org/2005/rules/wg/wiki/">Old Wiki</a></li>
				<li id="n-Telecon-Regrets"><a href="http://www.w3.org/2005/rules/wiki/TeleconRegrets">Telecon Regrets</a></li>
				<li id="n-help"><a href="http://www.w3.org/2007/OWL/wiki/Help:Contents" title="The place to find out.">Help</a></li>
				<li id="n-recentchanges"><a href="http://www.w3.org/2005/rules/wiki/Special:Recentchanges" title="The list of recent changes in the wiki. [alt-r]" accesskey="r">Recent changes</a></li>
			</ul>
		</div>
	</div>
		<div class="portlet" id="p-Drafts">
		<h5>Drafts</h5>
		<div class="pBody">
			<ul>
				<li id="n-UCR"><a href="http://www.w3.org/2005/rules/wiki/UCR">UCR</a></li>
				<li id="n-Core"><a href="http://www.w3.org/2005/rules/wiki/Core">Core</a></li>
				<li id="n-BLD"><a href="http://www.w3.org/2005/rules/wiki/BLD">BLD</a></li>
				<li id="n-FLD"><a href="http://www.w3.org/2005/rules/wiki/FLD">FLD</a></li>
				<li id="n-RDF.2BOWL"><a href="http://www.w3.org/2005/rules/wiki/SWC">RDF+OWL</a></li>
				<li id="n-DTB"><a href="http://www.w3.org/2005/rules/wiki/DTB">DTB</a></li>
				<li id="n-PRD"><a href="http://www.w3.org/2005/rules/wiki/PRD">PRD</a></li>
				<li id="n-Test"><a href="http://www.w3.org/2005/rules/wiki/Test">Test</a></li>
			</ul>
		</div>
	</div>
		<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/2005/rules/wiki/Special:Search" id="searchform"><div>
				<input id="searchInput" name="search" title="Search RIF [alt-f]" accesskey="f" value="" type="text">
				<input name="go" class="searchButton" id="searchGoButton" value="Go" type="submit">&nbsp;
				<input name="fulltext" class="searchButton" id="mw-searchButton" value="Search" type="submit">
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="http://www.w3.org/2005/rules/wiki/Special:Whatlinkshere/BLD" title="List of all wiki pages that link here [alt-j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="http://www.w3.org/2005/rules/wiki/Special:Recentchangeslinked/BLD" title="Recent changes in pages linked from this page [alt-k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="http://www.w3.org/2005/rules/wiki/Special:Upload" title="Upload files [alt-u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="http://www.w3.org/2005/rules/wiki/Special:Specialpages" title="List of all special pages [alt-q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="http://www.w3.org/2005/rules/wiki/index.php?title=BLD&amp;printable=yes" title="Printable version of this page [alt-p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="http://www.w3.org/2005/rules/wiki/index.php?title=BLD&amp;oldid=10525" title="Permanent link to this version of the page">Permanent link</a></li>			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="BLD_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki"></a></div>
			<ul id="f-list">
				<li id="lastmod"> This page was last modified 21:41, 3 July 2009.</li>
				<li id="viewcount">This page has been accessed 73,974 times.</li>
				<li id="privacy"><a href="http://www.w3.org/2005/rules/wiki/RIF:Privacy_policy" title="RIF:Privacy policy">Privacy policy</a></li>
				<li id="about"><a href="http://www.w3.org/2005/rules/wiki/RIF:About" title="RIF:About">About RIF</a></li>
				<li id="disclaimer"><a href="http://www.w3.org/2005/rules/wiki/RIF:General_disclaimer" title="RIF:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
		
	
		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
</div>
<!-- Served in 4.861 secs. --></body></html>